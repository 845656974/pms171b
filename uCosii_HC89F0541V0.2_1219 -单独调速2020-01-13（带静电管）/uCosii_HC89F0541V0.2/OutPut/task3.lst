C51 COMPILER V9.60.0.0   TASK3                                                             02/22/2021 15:08:10 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE TASK3
OBJECT MODULE PLACED IN .\OutPut\task3.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Source\task3.c LARGE OPTIMIZE(9,SPEED) BROWSE INCDIR(.\Source;.\uCosii) 
                    -DEBUG OBJECTEXTEND PRINT(.\OutPut\task3.lst) TABS(2) OBJECT(.\OutPut\task3.obj)

line level    source

   1          #include "includes.h"
   2          #include "Source\task3.h"
   3          
   4          INT8U run_stop_flag =0;//90°直角停止标志，在中断内触发
   5          INT8U run_stop_flag_R =0;//90°直角开始标志，在开始直角中触发开启
   6          INT8U run_stop_flag_L =0;//90°直角开始标志，在开始直角中触发开启
   7          
   8          INT8U  num_L=0;       //左轮码盘值
   9          INT8U num_L1 = 0;     //左轮码盘值
  10          int num_L2=0;         //左轮码盘值
  11          int sum_L=0;            //累计偏差
  12          int count_L_1=0;        //编码器本次偏差
  13          int count_L_2=0;        //编码器上次偏差
  14          int count_sum_L = 0;    //系统偏差，用于pid的d
  15          int count_sum1_L = 0;   //系统偏差，当前偏差
  16          int count_sum2_L = 0;   //系统偏差，上一次偏差
  17          int count_sum3_L = 0;   //系统偏差，上上次偏差
  18          int pwm_L=0;      //PWM值0-2048
  19          
  20          INT8U  num_R=0;       //右轮码盘值
  21          INT8U  num_R1=0;        //右轮码盘值
  22          int num_R2=0;       //右轮码盘值
  23          int sum_R=0;            //累计偏差
  24          int count_R_1=0;        //编码器本次偏差
  25          int count_R_2=0;        //编码器上次偏差
  26          int count_sum_R = 0;    //系统偏差，用于pid的d
  27          int count_sum1_R = 0;   //系统偏差，当前偏差
  28          int count_sum2_R = 0;   //系统偏差，上一次偏差
  29          int count_sum3_R = 0;   //系统偏差，上上次偏差
  30          int pwm_R=0;      //PWM值0-2048
  31          
  32          
  33          
  34          int f3_crash1= 0;//后退次数
  35          int   f3_count = 0;//步数计数器
  36          bool  f3_flag0 = 1;//按键启动标志，一般用于按键按下执行第一次操作
  37          INT8U   f3_flag1 = 0;//记录标志，一般用于第一次复位
  38          INT8U f3_flag3 = 0;//旋转完毕计数器,6次跳出绕物，进行120度旋转
  39          int   f3_flag4 = 0;//重点清扫模式计数器
  40          INT8U f3_flag5 = 0;//120°次数
  41          
  42          bool fan_open = 0;//风机开启1,关闭0
  43          INT32U f3_fengji = 0;
  44          
  45          int f3_flag = -1;//步骤运行，共100多步骤
  46          
  47          //f2
  48          extern INT8U f2_mode ;//模式0停止 1弓形 2回充 3充电 4快闪 5慢闪 6异常 7方向按键 10定点 11待机
  49          extern INT8U TK_ZJ;//自检模式
  50          
  51          extern INT8U  BUZZER_flag ;//蜂鸣器
  52          extern INT8U  BUZZER_num ;//蜂鸣器计数器，用于响应时间
  53          extern bool sensor_error ;//传感器状态，地检墙检碰撞
  54          
C51 COMPILER V9.60.0.0   TASK3                                                             02/22/2021 15:08:10 PAGE 2   

  55          
  56          
  57          void Task3(void *ppdata) reentrant
  58          {
  59   1        initialize_pwm();//初始化PWM
  60   1      
  61   1        ppdata = ppdata;
  62   1          OSTimeDly(1000);
  63   1        while(1){
  64   2      /***********************弓形、定点、快慢闪初始化*******************************/    
  65   2      f3_run_first();// 弓形、定点、快慢闪初始化
  66   2      /***********************停止运行*******************************/  
  67   2      f3_stop();      //  停止运行    
  68   2        
  69   2      /***********************弓形*******************************/      
  70   2      f3_run();   
  71   2          
  72   2      /***********************自检轮子测试*******************************/          
  73   2      f3_run_ZJ();//  自检轮子测试      
  74   2      /***********************WIFI方向按键*******************************/          
  75   2      f3_run_WIFI();//  自检轮子测试  
  76   2        
  77   2        
  78   2          OSTimeDly(15);
  79   2          
  80   2          
  81   2          
  82   2        }  }
  83          
  84          
  85            
  86          void f3_run(void)     //  正常
  87          {
  88   1      //      IE &=~ 0x10;        //允许UART1中断
  89   1      //      SBUF = 0xFF;//task1发送8位串口数据
  90   1      //      while(!(SCON & 0x02));
  91   1      //      SCON &=~ 0x02;      //清除发送中断标志位
  92   1      //      
  93   1      //      SBUF = 0xFE;//task1发送8位串口数据
  94   1      //      while(!(SCON & 0x02));
  95   1      //      SCON &=~ 0x02;      //清除发送中断标志位
  96   1      
  97   1      //      SBUF = 0x01;//task1发送8位串口数据
  98   1      //      while(!(SCON & 0x02));
  99   1      //      SCON &=~ 0x02;      //清除发送中断标志位
 100   1        
 101   1      //      SBUF = num_L1;//task1发送8位串口数据
 102   1      //      while(!(SCON & 0x02));
 103   1      //      SCON &=~ 0x02;      //清除发送中断标志位
 104   1      
 105   1        
 106   1      if(f3_flag==0)//步骤0 直行
 107   1      {
 108   2        if(f3_flag1==0)//重置PWM
 109   2        {
 110   3          run_stop_flag_R =0;//90°直角开始标志，在开始直角中触发开启
 111   3          run_stop_flag_L =0;//90°直角开始标志，在开始直角中触发开启
 112   3          f3_count = 0;//步数计数器，用于走的长度
 113   3          reset_pwm();
 114   3          f3_flag1 = 1;//不在进入重置
 115   3          OSTimeDly(10);
 116   3        }   
C51 COMPILER V9.60.0.0   TASK3                                                             02/22/2021 15:08:10 PAGE 3   

 117   2        f3_count++;//步数计数器
 118   2        if(sensor_error==0)//碰撞和地检都正常
 119   2        {
 120   3            advance_L(1,20,0);
 121   3            advance_R(1,20,0);
 122   3        }
 123   2        else//碰撞
 124   2        {
 125   3          f3_flag1 = 0;//记录标志，一般用于步骤第一次复位
 126   3          f3_flag = 1;//进入步骤1
 127   3        }
 128   2        if(f3_count >600)
 129   2        {
 130   3        f3_flag1 =0;//计数器
 131   3        f3_flag =2;//跳过步骤1后退，直接君如旋转
 132   3        }
 133   2      } 
 134   1      
 135   1      if(f3_flag==1)//步骤1 碰撞后退
 136   1      {
 137   2        if(f3_flag1==0)//重置PWM
 138   2        {
 139   3          run_stop_flag_R =0;//90°直角开始标志，在开始直角中触发开启
 140   3          run_stop_flag_L =0;//90°直角开始标志，在开始直角中触发开启
 141   3          f3_count = 0;//步数计数器，用于走的长度
 142   3          reset_pwm();
 143   3          f3_flag1 = 1;//不在进入重置
 144   3          OSTimeDly(50);
 145   3        }
 146   2      
 147   2        back(12,20);  //后退20次，进入步骤12  
 148   2      }
 149   1      if(f3_flag==2)//步骤2，右转
 150   1      {
 151   2        if(f3_flag1==0)//重置PWM
 152   2        {
 153   3          run_stop_flag = 0;//90°直角停止标志，在中断内触发
 154   3          run_stop_flag_R =1;//90°直角开始标志，在开始直角中触发开启
 155   3          run_stop_flag_L =0;//90°直角开始标志，在开始直角中触发开启
 156   3          f3_count = 0;
 157   3          reset_pwm();//重置PWM
 158   3          f3_flag1= 1;//不在进入重置
 159   3          OSTimeDly(50);
 160   3        }
 161   2        f3_count ++;//步数计数器
 162   2        if(sensor_error==0&&run_stop_flag ==0)//碰撞和地检都正常,且中断内的90°计数器没有到1
 163   2        {
 164   3          advance_L(1,15,0);
 165   3          advance_R(0,15,0);
 166   3        }
 167   2        if(sensor_error || run_stop_flag ||f3_count>100)//碰撞和地检异常||90°完成||计数器溢出75
 168   2        {
 169   3        f3_flag1 =0;//计数器
 170   3        f3_flag =3;//跳过步骤1后退，直接君如旋转
 171   3        }
 172   2      }
 173   1      if(f3_flag==3)//步骤3，右转后直行
 174   1      {
 175   2        if(f3_flag1==0)//重置PWM
 176   2        {
 177   3          run_stop_flag_R =0;//90°直角开始标志，在开始直角中触发开启
 178   3          run_stop_flag_L =0;//90°直角开始标志，在开始直角中触发开启
C51 COMPILER V9.60.0.0   TASK3                                                             02/22/2021 15:08:10 PAGE 4   

 179   3          f3_count = 0;
 180   3          reset_pwm();//重置PWM
 181   3          f3_flag1= 1;//不在进入重置
 182   3          OSTimeDly(50);
 183   3        }
 184   2        f3_count++;//步数计数器
 185   2        if(sensor_error==0)
 186   2        {
 187   3          advance_L(1,15,0);
 188   3          advance_R(1,15,0);
 189   3        }
 190   2        else//碰撞
 191   2        {
 192   3          f3_flag = 40;//进入步骤40
 193   3          f3_flag3 =0;//旋转完毕计数器,6次跳出绕物，进行120度旋转
 194   3          f3_flag1 =0;//计数器
 195   3        }
 196   2        if(f3_count>80)
 197   2        {
 198   3          f3_flag1=0;
 199   3          f3_flag=4;
 200   3        } 
 201   2      }
 202   1      if(f3_flag==4)//步骤4，右转
 203   1      {
 204   2        if(f3_flag1==0)//重置PWM
 205   2        {
 206   3          run_stop_flag = 0;//90°直角停止标志，在中断内触发
 207   3          run_stop_flag_R =1;//90°直角开始标志，在开始直角中触发开启
 208   3          run_stop_flag_L =0;//90°直角开始标志，在开始直角中触发开启
 209   3          f3_count = 0;
 210   3          reset_pwm();//重置PWM
 211   3          f3_flag1= 1;//不在进入重置
 212   3          OSTimeDly(50);
 213   3        }
 214   2        f3_count ++;//步数计数器
 215   2        if(sensor_error==0&&run_stop_flag ==0)//碰撞和地检都正常,且中断内的90°计数器没有到1
 216   2        {
 217   3          advance_L(1,15,0);
 218   3          advance_R(0,15,0);
 219   3        }
 220   2        if(sensor_error || run_stop_flag ||f3_count>100)//碰撞和地检异常||90°完成||计数器溢出75
 221   2        {
 222   3        f3_flag1 =0;//计数器
 223   3        f3_flag =5;//跳过步骤1后退，直接君如旋转
 224   3        }
 225   2      }
 226   1      if(f3_flag==5)//步骤5，右转后直行
 227   1      {
 228   2        if(f3_flag1==0)//重置PWM
 229   2        {
 230   3          run_stop_flag_R =0;//90°直角开始标志，在开始直角中触发开启
 231   3          run_stop_flag_L =0;//90°直角开始标志，在开始直角中触发开启
 232   3          f3_count = 0;
 233   3          reset_pwm();//重置PWM
 234   3          f3_flag1= 1;//不在进入重置
 235   3          OSTimeDly(50);
 236   3        }
 237   2        f3_count++;
 238   2        if(sensor_error==0)
 239   2        {
 240   3          advance_R(1,20,0);
C51 COMPILER V9.60.0.0   TASK3                                                             02/22/2021 15:08:10 PAGE 5   

 241   3          advance_L(1,20,0);
 242   3        }
 243   2        else
 244   2        {
 245   3          f3_flag = 6;
 246   3          f3_flag1 = 0;
 247   3        } 
 248   2        if(f3_count >600)
 249   2        {
 250   3        f3_flag1 =0;//计数器
 251   3        f3_flag =7;//跳过步骤1后退，直接君如旋转
 252   3        }
 253   2      }
 254   1      if(f3_flag==6)//步骤6，碰撞后退
 255   1      {
 256   2        if(f3_flag1==0)//重置PWM
 257   2        {
 258   3          run_stop_flag_R =0;//90°直角开始标志，在开始直角中触发开启
 259   3          run_stop_flag_L =0;//90°直角开始标志，在开始直角中触发开启
 260   3          f3_count = 0;//步数计数器，用于走的长度
 261   3          reset_pwm();
 262   3          f3_flag1 = 1;//不在进入重置
 263   3          OSTimeDly(50);
 264   3        }
 265   2        
 266   2        back(17,20);  //后退10次，进入步骤17  
 267   2      }
 268   1      if(f3_flag==7)//步骤7，碰撞后退进行左转
 269   1      {
 270   2        if(f3_flag1==0)//重置PWM
 271   2        {
 272   3          run_stop_flag = 0;//90°直角停止标志，在中断内触发
 273   3          run_stop_flag_R =0;//90°直角开始标志，在开始直角中触发开启
 274   3          run_stop_flag_L =1;//90°直角开始标志，在开始直角中触发开启
 275   3          f3_count = 0;
 276   3          reset_pwm();//重置PWM
 277   3          f3_flag1= 1;//不在进入重置
 278   3          OSTimeDly(50);
 279   3        }
 280   2      //  f3_count ++;//步数计数器
 281   2        if(sensor_error==0&&run_stop_flag ==0)//碰撞和地检都正常,且中断内的90°计数器没有到1
 282   2        {
 283   3          advance_R(1,15,0);
 284   3          advance_L(0,15,0);  
 285   3        }
 286   2        if(sensor_error || run_stop_flag ||f3_count>100)//碰撞和地检异常||90°完成||计数器溢出75
 287   2        {
 288   3        f3_flag1 =0;//计数器
 289   3        f3_flag =8;//跳过步骤1后退，直接君如旋转
 290   3        }
 291   2      }
 292   1      if(f3_flag==8)//步骤8，左转后直行
 293   1      {
 294   2        if(f3_flag1==0)//重置PWM
 295   2        {
 296   3          run_stop_flag_R =0;//90°直角开始标志，在开始直角中触发开启
 297   3          run_stop_flag_L =0;//90°直角开始标志，在开始直角中触发开启
 298   3          f3_count = 0;
 299   3          reset_pwm();//重置PWM
 300   3          f3_flag1= 1;//不在进入重置
 301   3          OSTimeDly(50);
 302   3        }
C51 COMPILER V9.60.0.0   TASK3                                                             02/22/2021 15:08:10 PAGE 6   

 303   2        f3_count++;//步数计数器
 304   2        if(sensor_error==0)
 305   2        {
 306   3          advance_R(1,15,0);
 307   3          advance_L(1,15,0);
 308   3        }
 309   2        else//碰撞
 310   2        {
 311   3          f3_flag = 20;//进入步骤40
 312   3          f3_flag3 =0;//旋转完毕计数器
 313   3          f3_flag1 =0;//计数器
 314   3        }
 315   2        if(f3_count>80)
 316   2        {
 317   3          f3_flag1=0;
 318   3          f3_flag=9;
 319   3        } 
 320   2      }
 321   1      if(f3_flag==9)//步骤9，左转
 322   1      {
 323   2        if(f3_flag1==0)//重置PWM
 324   2        {
 325   3          run_stop_flag = 0;//90°直角停止标志，在中断内触发
 326   3          run_stop_flag_R =0;//90°直角开始标志，在开始直角中触发开启
 327   3          run_stop_flag_L =1;//90°直角开始标志，在开始直角中触发开启
 328   3          f3_count = 0;
 329   3          reset_pwm();//重置PWM
 330   3          f3_flag1= 1;//不在进入重置
 331   3          OSTimeDly(50);
 332   3        }
 333   2        f3_count ++;//步数计数器
 334   2        if(sensor_error==0&&run_stop_flag ==0)//碰撞和地检都正常,且中断内的90°计数器没有到1
 335   2        {
 336   3          advance_R(1,15,0);
 337   3          advance_L(0,15,0);
 338   3        }
 339   2        if(sensor_error || run_stop_flag ||f3_count>100)//碰撞和地检异常||90°完成||计数器溢出75
 340   2        {
 341   3        f3_flag1 =0;//计数器
 342   3        f3_flag =0;//跳过步骤1后退，直接君如旋转
 343   3        }
 344   2      }
 345   1      
 346   1      if(f3_flag==12)//步骤2，右转
 347   1      {
 348   2        if(f3_flag1==0)//重置PWM
 349   2        {
 350   3          run_stop_flag = 0;//90°直角停止标志，在中断内触发
 351   3          run_stop_flag_R =2;//90°直角开始标志，在开始直角中触发开启
 352   3          run_stop_flag_L =0;//90°直角开始标志，在开始直角中触发开启
 353   3          f3_count = 0;
 354   3          reset_pwm();//重置PWM
 355   3          f3_flag1= 1;//不在进入重置
 356   3          OSTimeDly(50);
 357   3        }
 358   2        f3_count ++;//步数计数器
 359   2        if(sensor_error==0&&run_stop_flag ==0)//碰撞和地检都正常,且中断内的90°计数器没有到1
 360   2        {
 361   3          advance_L(1,15,0);
 362   3          advance_R(0,15,0);
 363   3        }
 364   2        if(sensor_error || run_stop_flag ||f3_count>100)//碰撞和地检异常||90°完成||计数器溢出75
C51 COMPILER V9.60.0.0   TASK3                                                             02/22/2021 15:08:10 PAGE 7   

 365   2        {
 366   3        f3_flag1 =0;//计数器
 367   3        f3_flag =3;//跳过步骤1后退，直接君如旋转
 368   3        } 
 369   2      }
 370   1      
 371   1      if(f3_flag==17)//步骤2，左转
 372   1      {
 373   2        if(f3_flag1==0)//重置PWM
 374   2        {
 375   3          run_stop_flag = 0;//90°直角停止标志，在中断内触发
 376   3          run_stop_flag_R =0;//90°直角开始标志，在开始直角中触发开启
 377   3          run_stop_flag_L =2;//90°直角开始标志，在开始直角中触发开启
 378   3          f3_count = 0;
 379   3          reset_pwm();//重置PWM
 380   3          f3_flag1= 1;//不在进入重置
 381   3          OSTimeDly(50);
 382   3        }
 383   2        f3_count ++;//步数计数器
 384   2        if(sensor_error==0&&run_stop_flag ==0)//碰撞和地检都正常,且中断内的90°计数器没有到1
 385   2        {
 386   3          advance_L(0,15,0);
 387   3          advance_R(1,15,0);
 388   3        }
 389   2        if(sensor_error || run_stop_flag ||f3_count>100)//碰撞和地检异常||90°完成||计数器溢出75
 390   2        {
 391   3        f3_flag1 =0;//计数器
 392   3        f3_flag =8;//跳过步骤1后退，直接君如旋转
 393   3        }
 394   2        
 395   2      } 
 396   1      
 397   1      
 398   1      
 399   1      
 400   1      
 401   1      
 402   1      
 403   1      
 404   1      
 405   1      if(f3_flag==20)//步骤20，绕物，碰撞后后退
 406   1      {
 407   2        if(f3_flag1==0)//重置PWM
 408   2        {
 409   3          reset_pwm();//重置PWM
 410   3          f3_flag1= 1;//不在进入重置
 411   3          f3_count=15;
 412   3          OSTimeDly(50);
 413   3        }
 414   2        f3_count--;//后退计数器
 415   2        advance_L(0,15,0);
 416   2        advance_R(0,15,0);
 417   2        if(sensor_error)//碰撞
 418   2        {
 419   3          f3_count=15;  
 420   3        }
 421   2        if(f3_count==0)//后退完毕，执行21
 422   2        {
 423   3          f3_flag1=0;
 424   3          f3_flag=21;
 425   3        } 
 426   2      } 
C51 COMPILER V9.60.0.0   TASK3                                                             02/22/2021 15:08:10 PAGE 8   

 427   1      if(f3_flag==21)//步骤21，右边绕物
 428   1      {
 429   2        if(f3_flag1==0)//重置PWM
 430   2        {
 431   3          reset_pwm();//重置PWM
 432   3          f3_flag1= 1;//不在进入重置
 433   3          f3_count=0;
 434   3          OSTimeDly(50);
 435   3        }
 436   2        f3_count++;   //旋转切换计数器,切换左旋转到右或者右到左
 437   2        if(f3_count<50)
 438   2        {
 439   3          advance_L(1,2,1); 
 440   3          advance_R(1,20,1);
 441   3        }
 442   2        else
 443   2        {
 444   3          f3_flag =22;
 445   3          f3_flag1= 0;//不在进入重置  
 446   3        }
 447   2        if(sensor_error)//碰撞
 448   2        {
 449   3          f3_flag = 22;//进入步骤40
 450   3          f3_flag1 =0;//计数器
 451   3        }
 452   2      } 
 453   1      if(f3_flag==22)//步骤42，右边绕物
 454   1      {
 455   2        if(f3_flag1==0)//重置PWM
 456   2        {
 457   3          f3_flag3++;//旋转完毕计数器,6次跳出绕物，进行120度旋转
 458   3          f3_count=0;
 459   3          reset_pwm();//重置PWM
 460   3          f3_flag1= 1;//不在进入重置
 461   3          OSTimeDly(50);
 462   3        }
 463   2        f3_count++;
 464   2        if(f3_count<500)
 465   2        {
 466   3          advance_L(1,20,1);  
 467   3          advance_R(1,4,1);
 468   3        }
 469   2        else
 470   2        {
 471   3          f3_flag =23;
 472   3          f3_flag1= 0;//不在进入重置
 473   3        }
 474   2        if(sensor_error)//碰撞
 475   2        {
 476   3          f3_flag = 20;//进入步骤20
 477   3          f3_flag1 =0;//计数器
 478   3        }
 479   2        if(f3_flag3>=6)//绕完物
 480   2        {
 481   3          f3_flag3 = 0;
 482   3          f3_flag  =24;//步骤24
 483   3          f3_flag1 = 0;
 484   3          f3_flag5 = 0;//120°次数
 485   3        }
 486   2      }
 487   1      
 488   1      if(f3_flag==23)//步骤43，直行
C51 COMPILER V9.60.0.0   TASK3                                                             02/22/2021 15:08:10 PAGE 9   

 489   1      {
 490   2        if(f3_flag1==0)//重置PWM
 491   2        {
 492   3          reset_pwm();//重置PWM
 493   3          f3_flag1= 1;//不在进入重置
 494   3          f3_count = 0;
 495   3          OSTimeDly(50);
 496   3        }
 497   2        f3_count++;//步数计数器
 498   2        if(sensor_error==0)
 499   2        {
 500   3          advance_L(1,20,0);
 501   3          advance_R(1,20,0);  
 502   3        }
 503   2        else
 504   2        {
 505   3          f3_flag = 20;//进入步骤40，后退
 506   3          f3_flag1 =0;//计数器
 507   3        }
 508   2        if(f3_count>200)
 509   2        {
 510   3          f3_flag = 0;//回到50
 511   3          f3_flag1 = 0;//计数器
 512   3        } 
 513   2      }
 514   1      if(f3_flag==24)//绕柱玩准备走,120°
 515   1      {
 516   2        if(f3_flag1==0)//重置PWM
 517   2        {
 518   3          reset_pwm();//重置PWM
 519   3          f3_flag1= 1;//不在进入重置
 520   3          f3_count = 0;
 521   3          OSTimeDly(50);
 522   3        }
 523   2        f3_count++;//步数计数器
 524   2        if((sensor_error))
 525   2        {
 526   3          f3_flag = 26;
 527   3          f3_flag1=0;
 528   3        }
 529   2        else
 530   2        {
 531   3          advance_L(0,20,0);
 532   3          advance_R(1,20,0);
 533   3        }
 534   2        if(f3_count>66)
 535   2        {
 536   3          f3_flag = 25;
 537   3          f3_flag1 = 0;//计数器
 538   3        }     
 539   2      }
 540   1      if(f3_flag==25)///120°直行
 541   1      {
 542   2        if(f3_flag1==0)//重置PWM
 543   2        {
 544   3          f3_flag5++;//120°次数
 545   3          reset_pwm();//重置PWM
 546   3          f3_flag1= 1;//不在进入重置
 547   3          f3_count = 0;
 548   3          OSTimeDly(50);
 549   3        }
 550   2        f3_count++;//步数计数器
C51 COMPILER V9.60.0.0   TASK3                                                             02/22/2021 15:08:10 PAGE 10  

 551   2        if(sensor_error==0)
 552   2        {
 553   3          advance_L(1,20,0);
 554   3          advance_R(1,20,0);
 555   3        }
 556   2        else
 557   2        {
 558   3          f3_flag = 26;
 559   3          f3_flag1=0; 
 560   3        }
 561   2        if(f3_count>520)
 562   2        {
 563   3          f3_flag = 24;
 564   3          f3_flag1=0;
 565   3        }
 566   2        if(f3_flag5==3)     
 567   2        {
 568   3          f3_flag5 = 0;//120°次数
 569   3          f3_flag = 0;
 570   3          f3_flag1=0;
 571   3        
 572   3        }
 573   2      }
 574   1      if(f3_flag==26)//步骤46，碰撞后退
 575   1        {
 576   2          if(f3_flag1==0)//重置PWM
 577   2          {
 578   3            reset_pwm();//重置PWM
 579   3            f3_flag1= 1;//不在进入重置
 580   3            f3_count = 0;
 581   3            OSTimeDly(50);
 582   3          }
 583   2          back(24,20);//后退20，进入44
 584   2        }
 585   1      
 586   1      
 587   1      
 588   1      
 589   1      
 590   1      
 591   1      
 592   1      
 593   1      
 594   1      if(f3_flag==40)//步骤40，绕物，碰撞后后退
 595   1      {
 596   2        if(f3_flag1==0)//重置PWM
 597   2        {
 598   3          reset_pwm();//重置PWM
 599   3          f3_flag1= 1;//不在进入重置
 600   3          f3_count=15;
 601   3          OSTimeDly(50);
 602   3        }
 603   2        f3_count--;//后退计数器
 604   2        advance_L(0,15,0);
 605   2        advance_R(0,15,0);
 606   2        if(sensor_error)//碰撞
 607   2        {
 608   3          f3_count=15;  
 609   3        }
 610   2        if(f3_count==0)//后退完毕，执行41
 611   2        {
 612   3          f3_flag1=0;
C51 COMPILER V9.60.0.0   TASK3                                                             02/22/2021 15:08:10 PAGE 11  

 613   3          f3_flag=41;
 614   3        } 
 615   2      }
 616   1      if(f3_flag==41)//步骤41，左边绕物，后退完执行前进
 617   1      {
 618   2        if(f3_flag1==0)//重置PWM
 619   2        {
 620   3          reset_pwm();//重置PWM
 621   3          f3_flag1= 1;//不在进入重置
 622   3          f3_count=0;
 623   3          OSTimeDly(50);
 624   3        }
 625   2        f3_count++;   //旋转切换计数器,切换左旋转到右或者右到左
 626   2        if(f3_count<50)
 627   2        {
 628   3          advance_L(1,20,1);
 629   3          advance_R(1,2,1); 
 630   3        }
 631   2        else
 632   2        {
 633   3          f3_flag =42;
 634   3          f3_flag1= 0;//不在进入重置
 635   3        } 
 636   2        if(sensor_error)//碰撞
 637   2        {
 638   3          f3_flag = 40;//进入步骤40
 639   3          f3_flag1 =0;//计数器
 640   3        }
 641   2      }
 642   1      
 643   1      
 644   1      
 645   1      if(f3_flag==42)//步骤42，左边绕物
 646   1      {
 647   2        if(f3_flag1==0)//重置PWM
 648   2        {
 649   3          f3_flag3++;//旋转完毕计数器,6次跳出绕物，进行120度旋转
 650   3          f3_count=0;
 651   3          reset_pwm();//重置PWM
 652   3          f3_flag1= 1;//不在进入重置
 653   3          OSTimeDly(50);
 654   3        }
 655   2        f3_count++;
 656   2        if(f3_count<500)
 657   2        {
 658   3          advance_L(1,4,1);
 659   3          advance_R(1,20,1);  
 660   3        }
 661   2        else
 662   2        {
 663   3          f3_flag =43;
 664   3          f3_flag1= 0;//不在进入重置
 665   3        } 
 666   2        if(sensor_error)//碰撞
 667   2        {
 668   3          f3_flag = 40;//进入步骤40
 669   3          f3_flag1 =0;//计数器
 670   3        }
 671   2          if(f3_flag3>=6)//绕完物
 672   2        {
 673   3          f3_flag3 = 0;
 674   3          f3_flag  =44;//步骤44
C51 COMPILER V9.60.0.0   TASK3                                                             02/22/2021 15:08:10 PAGE 12  

 675   3          f3_flag1 = 0;
 676   3          f3_flag5 = 0;//120°次数
 677   3        }
 678   2      
 679   2      } 
 680   1      
 681   1      if(f3_flag==43)//步骤43，直行
 682   1      {
 683   2        if(f3_flag1==0)//重置PWM
 684   2        {
 685   3          reset_pwm();//重置PWM
 686   3          f3_flag1= 1;//不在进入重置
 687   3          f3_count = 0;
 688   3          OSTimeDly(50);
 689   3        }
 690   2        f3_count++;//步数计数器
 691   2        if(sensor_error==0)
 692   2        {
 693   3          advance_L(1,20,0);
 694   3          advance_R(1,20,0);  
 695   3        }
 696   2        else
 697   2        {
 698   3          f3_flag = 40;//进入步骤40，后退
 699   3          f3_flag1 =0;//计数器
 700   3        }
 701   2        if(f3_count>200)
 702   2        {
 703   3          f3_flag = 50;//回到50
 704   3          f3_flag1 = 0;//计数器
 705   3        } 
 706   2      }
 707   1      
 708   1      
 709   1      if(f3_flag==44)//绕柱玩准备走,120°
 710   1      {
 711   2        if(f3_flag1==0)//重置PWM
 712   2        {
 713   3          reset_pwm();//重置PWM
 714   3          f3_flag1= 1;//不在进入重置
 715   3          f3_count = 0;
 716   3          OSTimeDly(50);
 717   3        }
 718   2          f3_count++;//步数计数器
 719   2        if(sensor_error)
 720   2        {
 721   3          f3_flag = 46;
 722   3          f3_flag1=0;
 723   3        }
 724   2        else
 725   2        {
 726   3          advance_L(1,20,0);
 727   3          advance_R(0,20,0);
 728   3        }
 729   2        if(f3_count>66)
 730   2        {
 731   3          f3_flag = 45;
 732   3          f3_flag1 = 0;//计数器
 733   3        }     
 734   2      }
 735   1      
 736   1      if(f3_flag==45)///120°执行完毕，直行
C51 COMPILER V9.60.0.0   TASK3                                                             02/22/2021 15:08:10 PAGE 13  

 737   1      {
 738   2        if(f3_flag1==0)//重置PWM
 739   2        {
 740   3          f3_flag5++;//120°次数
 741   3          reset_pwm();//重置PWM
 742   3          f3_flag1= 1;//不在进入重置
 743   3          f3_count = 0;
 744   3          OSTimeDly(50);
 745   3        }
 746   2        f3_count++;//步数计数器
 747   2        if(sensor_error==0)
 748   2        {
 749   3          advance_L(1,20,0);
 750   3          advance_R(1,20,0);
 751   3        }
 752   2        else
 753   2        {
 754   3          f3_flag = 46;
 755   3          f3_flag1=0; 
 756   3        }
 757   2        if(f3_count>520)
 758   2        {
 759   3          f3_flag = 44;
 760   3          f3_flag1=0;
 761   3        }
 762   2        if(f3_flag5==3)     
 763   2        {
 764   3          f3_flag5 = 0;//120°次数
 765   3          f3_flag = 50;
 766   3          f3_flag1=0;
 767   3        
 768   3        }
 769   2      }
 770   1      if(f3_flag==46)//步骤46，碰撞后退
 771   1      {
 772   2        if(f3_flag1==0)//重置PWM
 773   2        {
 774   3          reset_pwm();//重置PWM
 775   3          f3_flag1= 1;//不在进入重置
 776   3          f3_count = 0;
 777   3          OSTimeDly(50);
 778   3        }
 779   2        back(44,20);//后退20，进入44
 780   2      }
 781   1      
 782   1      
 783   1        
 784   1        
 785   1        
 786   1      if(f3_flag==50)//步骤50 直行
 787   1      {
 788   2        if(f3_flag1==0)//重置PWM
 789   2        {
 790   3          run_stop_flag_R =0;//90°直角开始标志，在开始直角中触发开启
 791   3          run_stop_flag_L =0;//90°直角开始标志，在开始直角中触发开启
 792   3          f3_count = 0;//步数计数器，用于走的长度
 793   3          reset_pwm();
 794   3          f3_flag1 = 1;//不在进入重置
 795   3          OSTimeDly(50);
 796   3        }   
 797   2        f3_count++;//步数计数器
 798   2        if(sensor_error==0)
C51 COMPILER V9.60.0.0   TASK3                                                             02/22/2021 15:08:10 PAGE 14  

 799   2        {
 800   3      
 801   3            advance_R(1,20,0);
 802   3            advance_L(1,20,0);
 803   3        }
 804   2        else//碰撞
 805   2        {
 806   3          f3_flag1 = 0;//记录标志，一般用于步骤第一次复位
 807   3          f3_flag = 51;//进入步骤51
 808   3        }
 809   2        if(f3_count >600)
 810   2        {
 811   3        f3_flag1 =0;//计数器
 812   3        f3_flag =52;//跳过步骤1后退，直接君如旋转
 813   3        }
 814   2      }
 815   1        
 816   1        
 817   1      if(f3_flag==51)//步骤51 碰撞后退
 818   1      {
 819   2        if(f3_flag1==0)//重置PWM
 820   2        {
 821   3          run_stop_flag_R =0;//90°直角开始标志，在开始直角中触发开启
 822   3          run_stop_flag_L =0;//90°直角开始标志，在开始直角中触发开启
 823   3          f3_count = 0;//步数计数器，用于走的长度
 824   3          reset_pwm();
 825   3          f3_flag1 = 1;//不在进入重置
 826   3          OSTimeDly(50);
 827   3        }
 828   2        
 829   2        back(62,20);  //后退20次，进入步骤2 
 830   2      }
 831   1        
 832   1      
 833   1      if(f3_flag==52)//步骤52，左转
 834   1      {
 835   2        if(f3_flag1==0)//重置PWM
 836   2        {
 837   3          run_stop_flag = 0;//90°直角停止标志，在中断内触发
 838   3          run_stop_flag_R =1;//90°直角开始标志，在开始直角中触发开启
 839   3          run_stop_flag_L =0;//90°直角开始标志，在开始直角中触发开启
 840   3          f3_count = 0;
 841   3          reset_pwm();//重置PWM
 842   3          f3_flag1= 1;//不在进入重置
 843   3        }
 844   2        f3_count ++;//步数计数器
 845   2        if(sensor_error==0&&run_stop_flag ==0)//碰撞和地检都正常,且中断内的90°计数器没有到1
 846   2        {
 847   3          advance_R(1,15,0);
 848   3          advance_L(0,15,0);
 849   3        }
 850   2        if(sensor_error || run_stop_flag ||f3_count>100)//碰撞和地检异常||90°完成||计数器溢出75
 851   2        {
 852   3        f3_flag1 =0;//计数器
 853   3        f3_flag =53;//跳过步骤1后退，直接君如旋转
 854   3        }
 855   2        
 856   2      }
 857   1      if(f3_flag==53)//步骤3，左转后直行
 858   1      {
 859   2        if(f3_flag1==0)//重置PWM
 860   2        {
C51 COMPILER V9.60.0.0   TASK3                                                             02/22/2021 15:08:10 PAGE 15  

 861   3          run_stop_flag_R =0;//90°直角开始标志，在开始直角中触发开启
 862   3          run_stop_flag_L =0;//90°直角开始标志，在开始直角中触发开启
 863   3          f3_count = 0;
 864   3          reset_pwm();//重置PWM
 865   3          f3_flag1= 1;//不在进入重置
 866   3          OSTimeDly(50);
 867   3        }
 868   2        f3_count++;//步数计数器
 869   2        if(sensor_error==0)
 870   2        {
 871   3          advance_R(1,15,0);
 872   3          advance_L(1,15,0);
 873   3        }
 874   2        else//碰撞
 875   2        {
 876   3          f3_flag = 20;//进入步骤20
 877   3          f3_flag3 =0;//旋转完毕计数器
 878   3          f3_flag1 =0;//计数器
 879   3        }
 880   2        if(f3_count>80)
 881   2        {
 882   3          f3_flag1=0;
 883   3          f3_flag=54;
 884   3        } 
 885   2      }
 886   1      if(f3_flag==54)//步骤54，左转
 887   1      {
 888   2        if(f3_flag1==0)//重置PWM
 889   2        {
 890   3          run_stop_flag = 0;//90°直角停止标志，在中断内触发
 891   3          run_stop_flag_R =0;//90°直角开始标志，在开始直角中触发开启
 892   3          run_stop_flag_L =1;//90°直角开始标志，在开始直角中触发开启
 893   3          f3_count = 0;
 894   3          reset_pwm();//重置PWM
 895   3          f3_flag1= 1;//不在进入重置
 896   3          OSTimeDly(50);
 897   3        }
 898   2        f3_count ++;//步数计数器
 899   2        if(sensor_error==0&&run_stop_flag ==0)//碰撞和地检都正常,且中断内的90°计数器没有到1
 900   2        {
 901   3          advance_L(0,15,0);
 902   3          advance_R(1,15,0);
 903   3        }
 904   2        if(sensor_error || run_stop_flag ||f3_count>100)//碰撞和地检异常||90°完成||计数器溢出75
 905   2        {
 906   3        f3_flag1 =0;//计数器
 907   3        f3_flag =55;//跳过步骤1后退，直接君如旋转
 908   3        }
 909   2      }
 910   1      if(f3_flag==55)//步骤5，左转后直行
 911   1      {
 912   2        if(f3_flag1==0)//重置PWM
 913   2        {
 914   3          run_stop_flag_R =0;//90°直角开始标志，在开始直角中触发开启
 915   3          run_stop_flag_L =0;//90°直角开始标志，在开始直角中触发开启
 916   3          f3_count = 0;
 917   3          reset_pwm();//重置PWM
 918   3          f3_flag1= 1;//不在进入重置
 919   3          OSTimeDly(50);
 920   3        }
 921   2        f3_count++;
 922   2        if(sensor_error==0)
C51 COMPILER V9.60.0.0   TASK3                                                             02/22/2021 15:08:10 PAGE 16  

 923   2        {
 924   3          advance_L(1,20,0);
 925   3          advance_R(1,20,0);
 926   3        }
 927   2        else
 928   2        {
 929   3          f3_flag = 56;
 930   3          f3_flag1 = 0;
 931   3        } 
 932   2        if(f3_count >600)
 933   2        {
 934   3        f3_flag1 =0;//计数器
 935   3        f3_flag =67;//跳过步骤1后退，直接君如旋转
 936   3        }
 937   2      }
 938   1      if(f3_flag==56)//步骤6，碰撞后退
 939   1      {
 940   2        if(f3_flag1==0)//重置PWM
 941   2        {
 942   3          run_stop_flag_R =0;//90°直角开始标志，在开始直角中触发开启
 943   3          run_stop_flag_L =0;//90°直角开始标志，在开始直角中触发开启
 944   3          f3_count = 0;//步数计数器，用于走的长度
 945   3          reset_pwm();
 946   3          f3_flag1 = 1;//不在进入重置
 947   3          OSTimeDly(50);
 948   3        }
 949   2        
 950   2        back(67,20);  //后退10次，进入步骤57
 951   2      }
 952   1      if(f3_flag==57)//步骤7，碰撞后退进行右转
 953   1      {
 954   2        if(f3_flag1==0)//重置PWM
 955   2        {
 956   3          run_stop_flag = 0;//90°直角停止标志，在中断内触发
 957   3          run_stop_flag_R =1;//90°直角开始标志，在开始直角中触发开启
 958   3          run_stop_flag_L =0;//90°直角开始标志，在开始直角中触发开启
 959   3          f3_count = 0;
 960   3          reset_pwm();//重置PWM
 961   3          f3_flag1= 1;//不在进入重置
 962   3          OSTimeDly(50);
 963   3        }
 964   2        f3_count ++;//步数计数器
 965   2        if(sensor_error==0&&run_stop_flag ==0)//碰撞和地检都正常,且中断内的90°计数器没有到1
 966   2        {
 967   3          advance_L(1,15,0);
 968   3          advance_R(0,15,0);
 969   3        }
 970   2        if(sensor_error || run_stop_flag ||f3_count>100)//碰撞和地检异常||90°完成||计数器溢出75
 971   2        {
 972   3        f3_flag1 =0;//计数器
 973   3        f3_flag =58;//跳过步骤1后退，直接君如旋转
 974   3        }
 975   2      }
 976   1      if(f3_flag==58)//步骤8，右转后直行
 977   1      {
 978   2        if(f3_flag1==0)//重置PWM
 979   2        {
 980   3          run_stop_flag_R =0;//90°直角开始标志，在开始直角中触发开启
 981   3          run_stop_flag_L =0;//90°直角开始标志，在开始直角中触发开启
 982   3          f3_count = 0;
 983   3          reset_pwm();//重置PWM
 984   3          f3_flag1= 1;//不在进入重置
C51 COMPILER V9.60.0.0   TASK3                                                             02/22/2021 15:08:10 PAGE 17  

 985   3          OSTimeDly(50);
 986   3        }
 987   2        f3_count++;//步数计数器
 988   2        if(sensor_error==0)
 989   2        {
 990   3          advance_L(1,15,0);
 991   3          advance_R(1,15,0);
 992   3        }
 993   2        else//碰撞
 994   2        {
 995   3          f3_flag = 40;//进入步骤40
 996   3          f3_flag3 =0;//旋转完毕计数器
 997   3          f3_flag1 =0;//计数器
 998   3        }
 999   2        if(f3_count>80)
1000   2        {
1001   3          f3_flag1=0;
1002   3          f3_flag=59;
1003   3        } 
1004   2      }
1005   1      if(f3_flag==59)//步骤9，右转
1006   1      {
1007   2        if(f3_flag1==0)//重置PWM
1008   2        {
1009   3          run_stop_flag = 0;//90°直角停止标志，在中断内触发
1010   3          run_stop_flag_R =1;//90°直角开始标志，在开始直角中触发开启
1011   3          run_stop_flag_L =0;//90°直角开始标志，在开始直角中触发开启
1012   3          f3_count = 0;
1013   3          reset_pwm();//重置PWM
1014   3          f3_flag1= 1;//不在进入重置
1015   3          OSTimeDly(50);
1016   3        }
1017   2        f3_count ++;//步数计数器
1018   2        if(sensor_error==0&&run_stop_flag ==0)//碰撞和地检都正常,且中断内的90°计数器没有到1
1019   2        {
1020   3          advance_L(1,15,0);
1021   3          advance_R(0,15,0);
1022   3        }
1023   2        if(sensor_error || run_stop_flag ||f3_count>100)//碰撞和地检异常||90°完成||计数器溢出75
1024   2        {
1025   3        f3_flag1 =0;//计数器
1026   3        f3_flag =50;//跳过步骤1后退，直接君如旋转
1027   3        }
1028   2      }
1029   1          
1030   1        
1031   1        
1032   1      
1033   1      if(f3_flag==62)//步骤2，左转
1034   1      {
1035   2        if(f3_flag1==0)//重置PWM
1036   2        {
1037   3          run_stop_flag = 0;//90°直角停止标志，在中断内触发
1038   3          run_stop_flag_R =0;//90°直角开始标志，在开始直角中触发开启
1039   3          run_stop_flag_L =2;//90°直角开始标志，在开始直角中触发开启
1040   3          f3_count = 0;
1041   3          reset_pwm();//重置PWM
1042   3          f3_flag1= 1;//不在进入重置
1043   3          OSTimeDly(50);
1044   3        }
1045   2        f3_count ++;//步数计数器
1046   2        if(sensor_error==0&&run_stop_flag ==0)//碰撞和地检都正常,且中断内的90°计数器没有到1
C51 COMPILER V9.60.0.0   TASK3                                                             02/22/2021 15:08:10 PAGE 18  

1047   2        {
1048   3          advance_R(1,15,0);
1049   3          advance_L(0,15,0);
1050   3        }
1051   2        if(sensor_error || run_stop_flag ||f3_count>100)//碰撞和地检异常||90°完成||计数器溢出75
1052   2        {
1053   3        f3_flag1 =0;//计数器
1054   3        f3_flag =53;//跳过步骤1后退，直接君如旋转
1055   3        }
1056   2      }
1057   1        
1058   1      if(f3_flag==67)//步骤2，右转
1059   1      {
1060   2        if(f3_flag1==0)//重置PWM
1061   2        {
1062   3          run_stop_flag = 0;//90°直角停止标志，在中断内触发
1063   3          run_stop_flag_R =2;//90°直角开始标志，在开始直角中触发开启
1064   3          run_stop_flag_L =0;//90°直角开始标志，在开始直角中触发开启
1065   3          f3_count = 0;
1066   3          reset_pwm();//重置PWM
1067   3          f3_flag1= 1;//不在进入重置
1068   3          OSTimeDly(50);
1069   3        }
1070   2        f3_count ++;//步数计数器
1071   2        if(sensor_error==0&&run_stop_flag ==0)//碰撞和地检都正常,且中断内的90°计数器没有到1
1072   2        {
1073   3          advance_L(1,15,0);
1074   3          advance_R(0,15,0);
1075   3        }
1076   2        if(sensor_error || run_stop_flag ||f3_count>100)//碰撞和地检异常||90°完成||计数器溢出75
1077   2        {
1078   3        f3_flag1 =0;//计数器
1079   3        f3_flag =58;//跳过步骤1后退，直接君如旋转
1080   3        }
1081   2        
1082   2      } 
1083   1      
1084   1      
1085   1      
1086   1      /**************************************************************** 
1087   1      *
1088   1      *重点清扫
1089   1      *
1090   1      *
1091   1      *****************************************************************/      
1092   1      if(f3_flag==70)//步骤2，右转
1093   1      {
1094   2        if(f3_flag1==0)//重置PWM
1095   2        {
1096   3          f3_count = 0;
1097   3          reset_pwm();//重置PWM
1098   3          f3_flag1= 1;//不在进入重置
1099   3        }
1100   2        f3_count ++;//步数计数器
1101   2        if(sensor_error==0)
1102   2        {
1103   3          advance_L(0,20,0);
1104   3          advance_R(1,20,0);
1105   3        }
1106   2        else
1107   2        {
1108   3          f3_flag1 =0;//计数器
C51 COMPILER V9.60.0.0   TASK3                                                             02/22/2021 15:08:10 PAGE 19  

1109   3          f3_flag =71;//跳过步骤1后退，直接进入旋转 
1110   3        
1111   3        }
1112   2        if(f3_count >100)
1113   2        {
1114   3        f3_flag1 =0;//计数器
1115   3        f3_flag =72;//跳过步骤1后退，直接进入旋转
1116   3        }
1117   2      
1118   2      }
1119   1      
1120   1      if(f3_flag==71)//半圈旋转碰撞后退
1121   1      {
1122   2        if(f3_flag1==0)//重置PWM
1123   2        {
1124   3          f3_count = 20;
1125   3          reset_pwm();//重置PWM
1126   3          f3_flag1= 1;//不在进入重置
1127   3        }
1128   2        f3_count --;//步数计数器
1129   2        if(sensor_error)//处于碰撞
1130   2        {
1131   3          f3_count=10;
1132   3        }
1133   2        if(f3_count >0)//后退
1134   2        {
1135   3          advance_L(0,20,0);
1136   3          advance_R(0,20,0);
1137   3        }
1138   2        if(f3_count==0)//碰撞解除和后退指令执行完毕，进入步骤70
1139   2        {
1140   3        f3_flag1 =0;//计数器
1141   3        f3_flag =70;//跳过步骤1后退，直接进入旋转 
1142   3        } 
1143   2      }
1144   1      if(f3_flag==72)//左旋转重点扫地
1145   1      {
1146   2        if(f3_flag1==0)//重置PWM
1147   2        {
1148   3          f3_count = 0;
1149   3          reset_pwm();//重置PWM
1150   3          f3_flag4=0;//旋转模式计数器
1151   3          f3_flag1= 1;//不在进入重置
1152   3        }
1153   2        
1154   2        if(sensor_error)//碰撞
1155   2        {
1156   3          f3_flag =73;  
1157   3        }
1158   2        else
1159   2        {
1160   3          if(f3_flag4>=0&&f3_flag4<1000)//[0,5)
1161   3          {
1162   4      //      if(f3_flag4==1)
1163   4      //      {
1164   4      //        BUZZER_flag=1;//开启蜂鸣器
1165   4      //        BUZZER_num=30;//蜂鸣器鸣叫时间
1166   4      //        }
1167   4            advance_L(1,f3_flag4/200,1);
1168   4            advance_R(1,20,1);    
1169   4          }
1170   3          if(f3_flag4>=1000&&f3_flag4<2000)//[5,8]
C51 COMPILER V9.60.0.0   TASK3                                                             02/22/2021 15:08:10 PAGE 20  

1171   3          {
1172   4      //      if(f3_flag4==1001)
1173   4      //      {
1174   4      //        BUZZER_flag=1;//开启蜂鸣器
1175   4      //        BUZZER_num=30;//蜂鸣器鸣叫时间
1176   4      //        }
1177   4            advance_L(1,2+f3_flag4/300,1);
1178   4            advance_R(1,20,1);    
1179   4          }
1180   3          if(f3_flag4>=2000&&f3_flag4<3500)//[8,11]
1181   3          {
1182   4      //      if(f3_flag4==2001)
1183   4      //      {
1184   4      //        BUZZER_flag=1;//开启蜂鸣器
1185   4      //        BUZZER_num=30;//蜂鸣器鸣叫时间
1186   4      //        }
1187   4            advance_L(1,3+f3_flag4/400,1);
1188   4            advance_R(1,20,1);    
1189   4          }
1190   3          if(f3_flag4>=3500&&f3_flag4<7500)//[11,14]
1191   3          {
1192   4      //      if(f3_flag4==3501)
1193   4      //      {
1194   4      //        BUZZER_flag=1;//开启蜂鸣器
1195   4      //        BUZZER_num=30;//蜂鸣器鸣叫时间
1196   4      //        }
1197   4            advance_L(1,9+f3_flag4/1500,1);
1198   4            advance_R(1,20,1);    
1199   4          }
1200   3          if(f3_flag4>=7500&&f3_flag4<10000)//[14,16]
1201   3          {
1202   4      //      if(f3_flag4==7501)
1203   4      //      {
1204   4      //        BUZZER_flag=1;//开启蜂鸣器
1205   4      //        BUZZER_num=30;//蜂鸣器鸣叫时间
1206   4      //        }
1207   4            advance_L(1,11+f3_flag4/2000,1);
1208   4            advance_R(1,20,1);    
1209   4          }
1210   3          
1211   3          if(f3_flag4>=10000)
1212   3          {
1213   4            
1214   4      //        BUZZER_flag=1;//开启蜂鸣器
1215   4      //        BUZZER_num=30;//蜂鸣器鸣叫时间
1216   4              
1217   4            f3_flag1 = 0;
1218   4            f3_flag = 74;
1219   4          }
1220   3        }
1221   2        f3_flag4++;
1222   2      }
1223   1      if(f3_flag==73)//步骤102，旋转碰撞后退
1224   1      {
1225   2        if(f3_flag1==0)//重置PWM
1226   2        {
1227   3          f3_count = 10;
1228   3          reset_pwm();//重置PWM
1229   3          f3_flag1= 1;//不在进入重置
1230   3        }
1231   2        f3_count--;
1232   2        if(sensor_error)
C51 COMPILER V9.60.0.0   TASK3                                                             02/22/2021 15:08:10 PAGE 21  

1233   2          f3_count = 10;
1234   2        if(f3_count>0)
1235   2        {
1236   3          advance_L(0,20,0);
1237   3          advance_R(0,20,0);
1238   3        }
1239   2        else
1240   2        {
1241   3          f3_flag=74;
1242   3          f3_flag1=0;
1243   3        } 
1244   2      }
1245   1      if(f3_flag==74)//左旋转左旋转180°第二次
1246   1      {
1247   2        if(f3_flag1==0)//重置PWM
1248   2        {
1249   3          f3_count = 0;
1250   3          reset_pwm();//重置PWM
1251   3          f3_flag1= 1;//不在进入重置
1252   3        }
1253   2        f3_count ++;//步数计数器
1254   2        if(sensor_error==0)
1255   2        {
1256   3          advance_L(0,20,0);
1257   3          advance_R(1,20,0);
1258   3        }
1259   2        else
1260   2        {
1261   3          f3_flag1 =0;//计数器
1262   3          f3_flag =75;//跳过步骤1后退，直接进入旋转 
1263   3        
1264   3        }
1265   2        if(f3_count >100)
1266   2        {
1267   3        f3_flag1 =0;//计数器
1268   3        f3_flag =76;//跳过步骤1后退，直接进入旋转
1269   3        }
1270   2      }
1271   1      if(f3_flag==75)//第二次半圈旋转碰撞后退
1272   1      {
1273   2        if(f3_flag1==0)//重置PWM
1274   2        {
1275   3          f3_count = 10;
1276   3          reset_pwm();//重置PWM
1277   3          f3_flag1= 1;//不在进入重置
1278   3        }
1279   2        f3_count --;//步数计数器
1280   2        if(sensor_error)//处于碰撞
1281   2        {
1282   3          f3_count=10;
1283   3        }
1284   2        if(f3_count >0)//后退
1285   2        {
1286   3          advance_L(0,20,0);
1287   3          advance_R(0,20,0);
1288   3        }
1289   2        if(f3_count==0)//碰撞解除和后退指令执行完毕，进入步骤70
1290   2        {
1291   3        f3_flag1 =0;//计数器
1292   3        f3_flag =76;//跳过步骤1后退，直接进入旋转 
1293   3        } 
1294   2      }
C51 COMPILER V9.60.0.0   TASK3                                                             02/22/2021 15:08:10 PAGE 22  

1295   1      if(f3_flag==76)//左旋转重点扫地
1296   1      {
1297   2        if(f3_flag1==0)//重置PWM
1298   2        {
1299   3          f3_count = 0;
1300   3          reset_pwm();//重置PWM
1301   3          f3_flag1= 1;//不在进入重置
1302   3        }
1303   2        
1304   2        if(sensor_error)//碰撞
1305   2        {
1306   3          f3_flag=-1;
1307   3          f3_flag1=0;
1308   3          reset_pwm();//重置PWM
1309   3          f2_mode=1;
1310   3          f3_flag0 =1;
1311   3      //      BUZZER_num=30;//蜂鸣器鸣叫时间
1312   3      //      BUZZER_flag=1;//开启蜂鸣器
1313   3        }
1314   2        else
1315   2        {
1316   3          if(f3_flag4>=0&&f3_flag4<1000)//[0,5)
1317   3          {
1318   4            advance_R(1,f3_flag4/200,1);
1319   4            advance_L(1,20,1);    
1320   4          }
1321   3          if(f3_flag4>=1000&&f3_flag4<2000)//[5,8]
1322   3          {
1323   4            advance_R(1,2+f3_flag4/300,1);
1324   4            advance_L(1,20,1);    
1325   4          }
1326   3          if(f3_flag4>=2000&&f3_flag4<3500)//[8,11]
1327   3          {
1328   4            advance_R(1,3+f3_flag4/400,1);
1329   4            advance_L(1,20,1);    
1330   4          }
1331   3          if(f3_flag4>=3500&&f3_flag4<7500)//[11,14]
1332   3          {
1333   4            advance_R(1,9+f3_flag4/1500,1);
1334   4            advance_L(1,20,1);    
1335   4          }
1336   3          if(f3_flag4>=7500&&f3_flag4<=10000)//[14,16]
1337   3          {
1338   4            advance_R(1,11+f3_flag4/2000,1);
1339   4            advance_L(1,20,1);    
1340   4          }
1341   3          if(f3_flag4<=0)
1342   3          {
1343   4            f3_flag=-1;
1344   4            f3_flag1=0;
1345   4            reset_pwm();//重置PWM
1346   4              f2_mode=1;
1347   4            f3_flag0 =1;
1348   4      
1349   4          }
1350   3          f3_flag4--;   
1351   3        }   
1352   2      }
1353   1      
1354   1      
1355   1      
1356   1      
C51 COMPILER V9.60.0.0   TASK3                                                             02/22/2021 15:08:10 PAGE 23  

1357   1      
1358   1      
1359   1      
1360   1      
1361   1      
1362   1      
1363   1      
1364   1      } 
1365          
1366          
1367          
1368          
1369          void back(int back_flag,int back_flag2)//后退
1370          {
1371   1        if(f3_flag1==1)//重置PWM
1372   1        {
1373   2          f3_crash1 = back_flag2;
1374   2          reset_pwm();//重置PWM
1375   2          f3_flag1= 2;//不在进入重置
1376   2      
1377   2        }
1378   1        if(sensor_error ) //后退计数器    //碰撞或者地检出问题
1379   1        {
1380   2      
1381   2          f3_crash1=back_flag2; //后退次数
1382   2        }
1383   1        if(f3_crash1>0)
1384   1        {
1385   2      
1386   2            advance_L(0,20,0);
1387   2            advance_R(0,20,0);
1388   2            f3_crash1--;
1389   2        }
1390   1        if(f3_crash1==0)//碰撞解除和后退指令执行完毕，进入步骤2
1391   1        {
1392   2          f3_flag= back_flag;
1393   2          f3_flag1= 0;//不在进入重置
1394   2        } 
1395   1      
1396   1      }
1397          
1398          
1399          
1400          
1401          
1402          
1403          
1404          
1405          void f3_stop(void)      //  停止运行  
1406          {
1407   1        if(f3_flag==-1)//步骤-1 暂停
1408   1        {
1409   2          if(f3_flag1==0)//重置PWM
1410   2          {
1411   3            if(TK_ZJ!=1)
1412   3            {
1413   4              Brush = 0;//边刷关闭
1414   4              fan = 0;//风机关闭
1415   4              fan_open = 0;//风机开启1,关闭0
1416   4            }
1417   3            f3_fengji=0;//弓形风机启动
1418   3            f3_count =0;//步数计数器，用于走的长度
C51 COMPILER V9.60.0.0   TASK3                                                             02/22/2021 15:08:10 PAGE 24  

1419   3            reset_pwm();
1420   3            f3_flag1 = 1;//不在进入重置
1421   3          }   
1422   2        }
1423   1      } 
1424            
1425          
1426          
1427          void f3_run_WIFI(void)  //  WIFI方向按键  
1428          {
1429   1      //wifi方向按键
1430   1      if(f3_flag==220)//步骤220 前进
1431   1      {
1432   2        if(f3_flag1==0)//重置PWM
1433   2        {
1434   3          Brush=1;//边刷
1435   3      //    fan=1;//风机
1436   3          fan_open = 1;//风机开启1,关闭0
1437   3          reset_pwm();
1438   3          f3_flag1 = 1;//不在进入重置
1439   3        }   
1440   2      
1441   2        if(sensor_error==0)
1442   2        {
1443   3          advance_L(1,20,0);
1444   3          advance_R(1,20,0);
1445   3        }
1446   2        else//碰撞
1447   2        {
1448   3          Brush=0;//边刷
1449   3          fan=0;//风机
1450   3          fan_open = 0;//风机开启1,关闭0
1451   3          reset_pwm();
1452   3          f3_flag=-1;
1453   3          f3_flag1 = 0;
1454   3        }
1455   2      }
1456   1      if(f3_flag==221)//步骤221 后退
1457   1      {
1458   2        if(f3_flag1==0)//重置PWM
1459   2        {
1460   3          Brush=1;//边刷
1461   3      //    fan=1;//风机
1462   3          fan_open = 1;//风机开启1,关闭0
1463   3          reset_pwm();
1464   3          f3_flag1 = 1;//不在进入重置
1465   3        }   
1466   2        if(sensor_error==0)
1467   2        {
1468   3          advance_L(0,20,0);
1469   3          advance_R(0,20,0);
1470   3        }
1471   2        else//碰撞
1472   2        {
1473   3          Brush=0;//边刷
1474   3          fan=0;//风机
1475   3          fan_open = 0;//风机开启1,关闭0
1476   3          reset_pwm();
1477   3          f3_flag=-1;
1478   3          f3_flag1 = 0;
1479   3        }
1480   2      }
C51 COMPILER V9.60.0.0   TASK3                                                             02/22/2021 15:08:10 PAGE 25  

1481   1      if(f3_flag==222)//步骤222 左
1482   1      {
1483   2        if(f3_flag1==0)//重置PWM
1484   2        {
1485   3          Brush=1;//边刷
1486   3      //    fan=1;//风机
1487   3          fan_open = 1;//风机开启1,关闭0
1488   3          reset_pwm();
1489   3          f3_flag1 = 1;//不在进入重置
1490   3        }   
1491   2        if(sensor_error==0)
1492   2        {
1493   3      
1494   3          advance_L(0,20,0);
1495   3          advance_R(1,20,0);
1496   3        }
1497   2        else//碰撞
1498   2        {
1499   3          Brush=0;//边刷
1500   3          fan=0;//风机
1501   3          fan_open = 0;//风机开启1,关闭0
1502   3          reset_pwm();
1503   3          f3_flag=-1;
1504   3          f3_flag1 = 0;
1505   3        }
1506   2      } 
1507   1      if(f3_flag==223)//步骤222 右
1508   1      {
1509   2        if(f3_flag1==0)//重置PWM
1510   2        {
1511   3          Brush=1;//边刷
1512   3      //    fan=1;//风机
1513   3          fan_open = 1;//风机开启1,关闭0
1514   3          reset_pwm();
1515   3          f3_flag1 = 1;//不在进入重置
1516   3        }   
1517   2        if(sensor_error==0)
1518   2        {
1519   3          advance_L(1,20,0);
1520   3          advance_R(0,20,0);
1521   3        }
1522   2        else//碰撞
1523   2        {
1524   3          Brush=0;//边刷
1525   3          fan=0;//风机
1526   3          fan_open = 0;//风机开启1,关闭0
1527   3          reset_pwm();
1528   3          f3_flag=-1;
1529   3          f3_flag1 = 0;
1530   3        }
1531   2      }
1532   1        
1533   1        
1534   1      }
1535          
1536          
1537          
1538          
1539          
1540          
1541          
1542          void f3_run_ZJ(void)//  自检轮子测试  
C51 COMPILER V9.60.0.0   TASK3                                                             02/22/2021 15:08:10 PAGE 26  

1543          {
1544   1      
1545   1      //自检测试
1546   1        if(f3_flag==200)//步骤200 左轮前进
1547   1        {   
1548   2          if(f3_flag1==0)//重置PWM
1549   2          {
1550   3            f3_count = 0;//步数计数器，用于走的长度
1551   3            reset_pwm();
1552   3            f3_flag1 = 1;//不在进入重置
1553   3          }   
1554   2            advance_L(1,25,1);
1555   2        } 
1556   1        if(f3_flag==201)//步骤200 右轮前进
1557   1        {
1558   2          if(f3_flag1==0)//重置PWM
1559   2          {
1560   3            f3_count = 0;//步数计数器，用于走的长度
1561   3            reset_pwm();
1562   3            f3_flag1 = 1;//不在进入重置
1563   3          }   
1564   2            advance_R(1,25,1);
1565   2        }
1566   1        if(f3_flag==202)//步骤200 左轮后退
1567   1        {
1568   2          if(f3_flag1==0)//重置PWM
1569   2          {
1570   3            f3_count = 0;//步数计数器，用于走的长度
1571   3            reset_pwm();
1572   3            f3_flag1 = 1;//不在进入重置
1573   3          }   
1574   2            advance_L(0,25,1);
1575   2        }   
1576   1        if(f3_flag==203)//步骤200 右轮后退
1577   1        {
1578   2          if(f3_flag1==0)//重置PWM
1579   2          {
1580   3            f3_count = 0;//步数计数器，用于走的长度
1581   3            reset_pwm();
1582   3            f3_flag1 = 1;//不在进入重置
1583   3          }   
1584   2            advance_R(0,25,1);
1585   2        }   
1586   1        if(f3_flag==204)//步骤200 2轮前进
1587   1        {
1588   2          if(f3_flag1==0)//重置PWM
1589   2          {
1590   3            f3_count = 0;//步数计数器，用于走的长度
1591   3            reset_pwm();
1592   3            f3_flag1 = 1;//不在进入重置
1593   3          }   
1594   2            advance_L(1,25,1);
1595   2            advance_R(1,25,1);
1596   2        } 
1597   1        if(f3_flag==205)//步骤200 2轮后退
1598   1        {
1599   2          if(f3_flag1==0)//重置PWM
1600   2          {
1601   3            f3_count = 0;//步数计数器，用于走的长度
1602   3            reset_pwm();
1603   3            f3_flag1 = 1;//不在进入重置
1604   3          }   
C51 COMPILER V9.60.0.0   TASK3                                                             02/22/2021 15:08:10 PAGE 27  

1605   2            advance_L(0,25,1);
1606   2            advance_R(0,25,1);
1607   2        }   
1608   1      
1609   1      } 
1610            
1611          void f3_run_first(void)// 弓形、定点、快慢闪初始化
1612          {
1613   1      if((f2_mode==0||f2_mode==4||f2_mode==5)&&f3_flag0&&TK_ZJ==0)//停止.4为快闪5为慢闪
1614   1      {
1615   2        f3_fengji=0;//弓形风机启动
1616   2        Brush = 0;//边刷关闭
1617   2        fan = 0;//风机关闭
1618   2        fan_open = 0;//风机开启1,关闭0
1619   2        f3_flag0 =0;//按键启动标志，一般用于按键按下执行第一次操作
1620   2        f3_flag=-1 ;//步骤运行，共100多步骤
1621   2        f3_flag1 = 0;//记录标志，一般用于步骤第一次复位
1622   2      } 
1623   1      
1624   1      if(f2_mode==1&&f3_flag0)//弓形
1625   1      {
1626   2        
1627   2        f3_fengji=0;//弓形风机启动
1628   2        Brush = 1;//边刷启动
1629   2      //  fan = 1;//风机关闭
1630   2        fan_open = 1;//风机开启1,关闭0
1631   2        f3_flag0 =0;//按键启动标志，一般用于按键按下执行第一次操作
1632   2        f3_flag=0 ;//步骤运行，共100多步骤
1633   2        f3_flag1 = 0;//记录标志，一般用于步骤第一次复位
1634   2      }
1635   1      
1636   1      
1637   1      if(f2_mode==10&&f3_flag0)//定点
1638   1      {
1639   2        f3_fengji=0;//弓形风机启动
1640   2        Brush = 1;//边刷启动
1641   2      //  fan = 1;//风机关闭
1642   2        fan_open = 1;//风机开启1,关闭0
1643   2        f3_flag0 =0;//按键启动标志，一般用于按键按下执行第一次操作
1644   2        f3_flag=70 ;//步骤运行，共100多步骤
1645   2        f3_flag1 = 0;//记录标志，一般用于步骤第一次复位
1646   2      }
1647   1      }
1648            
1649            
1650          
1651          
1652            
1653            
1654            
1655            
1656            
1657            
1658            
1659            
1660            
1661            
1662            
1663            
1664          /*****************PWM初始化*********************************************/
1665          static void initialize_pwm()
1666          {
C51 COMPILER V9.60.0.0   TASK3                                                             02/22/2021 15:08:10 PAGE 28  

1667   1        PWM0PH = 0x07;            //周期高4位设置为0x07
1668   1        PWM0PL = 0xFF;            //周期低8位设置为0xFF
1669   1        PWM1PH = 0x07;            //周期高4位设置为0x07
1670   1        PWM1PL = 0xFF;            //周期低8位设置为0xFF 
1671   1        PWM2PH = 0x07;            //周期高4位设置为0x07
1672   1        PWM2PL = 0xFF;            //周期低8位设置为0xFF 
1673   1        //占空比计算= 0x0155 / (Fosc / PWM分频系数)   （Fosc见系统时钟配置的部分）
1674   1        //      = 0x0155 / (16000000 / 8)     
1675   1        //      = 341    / 2000000
1676   1        //      = 170.5us      占空比为 170.5/511.5 = 33.3%
1677   1      /*****************右轮*********************************************/
1678   1        PWM0DH = 0;           //00PWM0高4位占空比0x01     P2.2
1679   1        PWM0DL = 0;           //00PWM0低8位占空比0x55     P2.3
1680   1        PWM0DTH = 0;            //03PWM01高4位占空比0x01    P2.2
1681   1        PWM0DTL = 00;           //55PWM01低8位占空比0x55    P2.3
1682   1      /*****************左轮*********************************************/
1683   1        PWM1DH = 0;           //00PWM0高4位占空比0x01     P
1684   1        PWM1DL = 0;           //00PWM0低8位占空比0x55
1685   1        PWM1DTH = 0;            //01PWM01高4位占空比0x01
1686   1        PWM1DTL = 00;           //55PWM01低8位占空比0x55
1687   1        
1688   1        
1689   1        
1690   1        PWM2DH = 0;           //00PWM0高4位占空比0x01     P
1691   1        PWM2DL = 0;           //00PWM0低8位占空比0x55
1692   1        PWM2DTH = 0;            //01PWM01高4位占空比0x01
1693   1        PWM2DTL = 00;           //55PWM01低8位占空比0x55
1694   1        
1695   1        
1696   1        
1697   1      //  PWM2PH = 0x03;            //周期高4位设置为0x03
1698   1      //  PWM2PL = 0xFF;            //周期低8位设置为0xFF
1699   1      //  PWM2DH = 2;           //00PWM0高4位占空比0x01     P
1700   1      //  PWM2DL = 0;           //00PWM0低8位占空比0x55
1701   1      //  PWM2DTH = 2;            //01PWM01高4位占空比0x01
1702   1      //  PWM2DTL = 00;           //55PWM01低8位占空比0x55
1703   1      
1704   1        PWMEN |= 0x77;            //使能PWM0以及PWM01   ，使能PWM1以及PWM01
1705   1      } 
1706            
1707            
1708            
1709          void reset_pwm(void)//PWM重置
1710          {
1711   1        /*****************右轮*********************************************/
1712   1        PWM0DH = 0;           //00PWM0高4位占空比0x01     P2.2
1713   1        PWM0DL = 0;           //00PWM0低8位占空比0x55     P2.3
1714   1        PWM0DTH = 0;            //03PWM01高4位占空比0x01    P2.2
1715   1        PWM0DTL = 00;           //55PWM01低8位占空比0x55    P2.3
1716   1      /*****************左轮*********************************************/
1717   1        PWM1DH = 0;           //00PWM0高4位占空比0x01     P
1718   1        PWM1DL = 0;           //00PWM0低8位占空比0x55
1719   1        PWM1DTH = 0;            //01PWM01高4位占空比0x01
1720   1        PWM1DTL = 00;           //55PWM01低8位占空比0x55
1721   1        
1722   1        
1723   1        num_L = 0;//编码器
1724   1        num_R = 0;//编码器
1725   1        num_L2 = 0;//编码器
1726   1        num_R2 = 0;//编码器
1727   1      } 
1728            
C51 COMPILER V9.60.0.0   TASK3                                                             02/22/2021 15:08:10 PAGE 29  

1729            
1730            
1731            
1732            
1733            
1734            
1735            
1736            
1737            
1738          //  
1739          ///*****************************************
1740          //go 1前进 0后退
1741          //v   速度
1742          
1743          //********************************************/
1744            
1745          void advance_L(int go,int v,int mode)//左边
1746          {
1747   1      //  int count_LR = 0;
1748   1        if (PWM1DTH==0&&PWM1DTL==0&&go==1)//前进初始化
1749   1          { 
1750   2      //    PWM1DTH=2;
1751   2      //    PWM1DTL=2;
1752   2          sum_L = 0;          //累积偏差
1753   2          count_L_1 = 0;      //编码器本次偏差
1754   2          count_L_2 = 0;      //编码器上次偏差
1755   2          num_L=0;            //左轮编码器
1756   2          
1757   2          count_sum_L = 0;    //系统偏差，用于pid的d
1758   2          count_sum1_L = 0;   //系统偏差，当前偏差
1759   2          count_sum2_L = 0;   //系统偏差，上一次偏差
1760   2          count_sum3_L = 0;   //系统偏差，上上次偏差
1761   2          pwm_L=600;  
1762   2            
1763   2        }
1764   1        if(PWM1DH==0&&PWM1DL==0&&go==0)//后退初始化
1765   1        { 
1766   2      //    PWM1DL = 2; 
1767   2      //    PWM1DH = 2;
1768   2          sum_L = 0;          //累积偏差
1769   2          count_L_1 = 0;      //编码器本次偏差
1770   2          count_L_2 = 0;      //编码器本次偏差
1771   2          num_L=0;            //左轮编码器
1772   2          
1773   2          count_sum_L = 0;    //系统偏差，用于pid的d
1774   2          count_sum1_L = 0;   //系统偏差，当前偏差
1775   2          count_sum2_L = 0;   //系统偏差，上一次偏差
1776   2          count_sum3_L = 0;   //系统偏差，上上次偏差
1777   2          pwm_L=600;
1778   2      
1779   2        }
1780   1        count_L_2 = count_L_1;      //上次偏差
1781   1        count_L_1 = v - num_L;      //本次偏差,与编码器做差
1782   1        count_sum3_L = count_sum2_L;//上上一次系统偏差
1783   1        count_sum2_L = count_sum1_L;//上一次系统偏差
1784   1        count_sum1_L = count_L_1;   //当前系统偏差
1785   1        sum_L += count_L_1;         //总的累积偏差
1786   1        count_sum_L = count_sum1_L-2*count_sum2_L+count_sum3_L;//系统偏差，用于pid的d
1787   1      
1788   1          /**************************************************************************
1789   1          函数功能：速度闭环控制PID控制器
1790   1          P 用于提高响应速度、I 用于减小静差、D 用于抑制震荡。
C51 COMPILER V9.60.0.0   TASK3                                                             02/22/2021 15:08:10 PAGE 30  

1791   1          返回  值：电机PWM
1792   1          根据位置式离散PID公式 
1793   1          pwm +=Kp*[e(k)-e(k-1)] + Ki*e(k)+Kd[e(k)-2e(k-1)+e(k-2)]
1794   1          e(k)代表本次偏差 
1795   1          e(k-1)代表上一次的偏差  
1796   1          ∑e(k)代表e(k)以及之前的偏差的累积和;其中k为1,2,,k;
1797   1          pwm代表输出
1798   1          **************************************************************************/
1799   1      //  count_LR = num_R2-num_L2;
1800   1      //  if(count_LR>100)
1801   1      //    count_LR=100;
1802   1      //  else if(count_LR<-100)
1803   1      //    count_LR=-100;
1804   1        
1805   1      
1806   1          if(mode==0)//正常模式 8 3 3
1807   1            pwm_L+=15*count_L_1+8*(count_L_1-count_L_2)+2*count_sum_L;
1808   1      //      pwm_L+=10*(count_L_1-count_L_2)+5*count_L_1+4*count_sum_L;
1809   1          else//mode==1非同步模式 4 2 2
1810   1            pwm_L+=5*count_L_1+10*(count_L_1-count_L_2)+5*count_sum_L;
1811   1          if(pwm_L>2000)//左轮限制最大速度
1812   1          {
1813   2            pwm_L=2000;
1814   2          }
1815   1          if(pwm_L<0)//左轮限制最小速度
1816   1          {
1817   2            pwm_L=0;  
1818   2          }
1819   1          if(go)//正方向
1820   1          {
1821   2            if(v==0)
1822   2            {
1823   3              PWM1DTH = 0;//左轮高位PWM
1824   3              PWM1DTL = 0;//左轮低位PWM
1825   3            
1826   3            }
1827   2            else
1828   2            {
1829   3              PWM1DTH = pwm_L/255;//左轮高位PWM
1830   3              PWM1DTL = pwm_L%255;//左轮低位PWM
1831   3            }
1832   2          }
1833   1          else//反方向
1834   1            {
1835   2            if(v==0)
1836   2            {
1837   3              PWM1DH = 0;//左轮高位PWM
1838   3              PWM1DL = 0;//左轮低位PWM
1839   3            
1840   3            }
1841   2            else
1842   2            {
1843   3              PWM1DH = pwm_L/255;//左轮高位PWM
1844   3              PWM1DL = pwm_L%255;//左轮低位PWM
1845   3            }
1846   2          }
1847   1          num_L1=num_L;
1848   1          num_L = 0;
1849   1      
1850   1      }
1851          
1852          
C51 COMPILER V9.60.0.0   TASK3                                                             02/22/2021 15:08:10 PAGE 31  

1853          
1854          
1855          void advance_R(int go,int v,int mode)//右边
1856          {
1857   1      //  int count_RL = 0;
1858   1        if (PWM0DH==0&&PWM0DL==0&&go==1)//前进初始化
1859   1          { 
1860   2      //    PWM0DH=2;
1861   2      //    PWM0DL=2;
1862   2          sum_R = 0;          //累积偏差
1863   2          count_R_1 = 0;      //编码器本次偏差
1864   2          count_R_2 = 0;      //编码器上次偏差
1865   2          num_R=0;            //左轮编码器
1866   2          
1867   2          count_sum_R = 0;    //系统偏差，用于pid的d
1868   2          count_sum1_R = 0;   //系统偏差，当前偏差
1869   2          count_sum2_R = 0;   //系统偏差，上一次偏差
1870   2          count_sum3_R = 0;   //系统偏差，上上次偏差
1871   2          pwm_R=600;
1872   2      
1873   2        }
1874   1        if(PWM0DTH==0&&PWM0DTL==0&&go==0)//后退初始化
1875   1        { 
1876   2      //    PWM0DTH = 2;  
1877   2      //    PWM0DTL = 2;
1878   2          sum_R = 0;          //累积偏差
1879   2          count_R_1 = 0;      //编码器本次偏差
1880   2          count_R_2 = 0;      //编码器本次偏差
1881   2          num_R=0;            //左轮编码器
1882   2          
1883   2          count_sum_R = 0;    //系统偏差，用于pid的d
1884   2          count_sum1_R = 0;   //系统偏差，当前偏差
1885   2          count_sum2_R = 0;   //系统偏差，上一次偏差
1886   2          count_sum3_R = 0;   //系统偏差，上上次偏差
1887   2          pwm_R=600;
1888   2        }
1889   1        count_R_2 = count_R_1;      //上次偏差
1890   1        count_R_1 = v - num_R;      //本次偏差,与编码器做差
1891   1        count_sum3_R = count_sum2_R;//上上一次系统偏差
1892   1        count_sum2_R = count_sum1_R;//上一次系统偏差
1893   1        count_sum1_R = count_R_1;   //当前系统偏差
1894   1        sum_R += count_R_1;         //总的累积偏差
1895   1        count_sum_R = count_sum1_R-2*count_sum2_R+count_sum3_R;//系统偏差，用于pid的d
1896   1          /**************************************************************************
1897   1          函数功能：速度闭环控制PID控制器
1898   1          P 用于提高响应速度、I 用于减小静差、D 用于抑制震荡。
1899   1          返回  值：电机PWM
1900   1          根据位置式离散PID公式 
1901   1          pwm +=Kp*[e(k)-e(k-1)] + Ki*e(k)+Kd[e(k)-2e(k-1)+e(k-2)]
1902   1          e(k)代表本次偏差 
1903   1          e(k-1)代表上一次的偏差  
1904   1          ∑e(k)代表e(k)以及之前的偏差的累积和;其中k为1,2,,k;
1905   1          pwm代表输出
1906   1          **************************************************************************/
1907   1      //    count_RL = num_L2-num_R2;
1908   1      //    if(count_RL>100)
1909   1      //    count_RL=100;
1910   1      //    else if(count_RL<(-1000))
1911   1      //    count_RL=-100;
1912   1          
1913   1      //            IE &=~ 0x10;        //允许UART1中断
1914   1      //        SBUF = count_RL/10;//task1发送8位串口数据
C51 COMPILER V9.60.0.0   TASK3                                                             02/22/2021 15:08:10 PAGE 32  

1915   1      //        while(!(SCON & 0x02));
1916   1      //        SCON &=~ 0x02;      //清除发送中断标志位
1917   1          
1918   1          
1919   1      //    val_right=40*(float)task1_count0+20*task1+30*(float)(task1_count0-task1_count01); 
1920   1      //    val_right+=+1*(task1_count22-task1_count11)+14*(task1_count0-task1_count01) + 7*task1_count0 +10*task1
             -_sum0; 
1921   1          if(mode==0)//同步模式 8 3 3
1922   1            pwm_R+=15*count_R_1+8*(count_R_1-count_R_2)+2*count_sum_R;
1923   1          else//mode==1非同步模式 4 2 2
1924   1            pwm_R+=5*count_R_1+10*(count_R_1-count_R_2)+5*count_sum_R;
1925   1        if(pwm_R>2000)//左轮限制最大速度
1926   1          {
1927   2            pwm_R=2000;
1928   2          }
1929   1          if(pwm_R<0)//左轮限制最小速度
1930   1          {
1931   2            pwm_R=0;  
1932   2          }
1933   1      
1934   1          
1935   1          
1936   1          if(go)//正方向
1937   1          {   
1938   2            if(v==0)
1939   2            {
1940   3              PWM0DH = 0;//左轮高位PWM
1941   3              PWM0DL = 0;//左轮低位PWM
1942   3            }
1943   2            else
1944   2            {
1945   3              PWM0DH = pwm_R/255;//左轮高位PWM
1946   3              PWM0DL = pwm_R%255;//左轮低位PWM
1947   3            }
1948   2              
1949   2      
1950   2          }
1951   1          else //反方向
1952   1          { 
1953   2            if(v==0)
1954   2            {
1955   3              PWM0DTH = 0;//左轮高位PWM
1956   3              PWM0DTL = 0;//左轮低位PWM
1957   3            }
1958   2            else
1959   2            {
1960   3                PWM0DTH = pwm_R/255;//左轮高位PWM
1961   3                PWM0DTL = pwm_R%255;//左轮低位PWM
1962   3            }
1963   2      
1964   2      
1965   2          }
1966   1          num_R1 = num_R;
1967   1          num_R = 0;
1968   1      
1969   1      }
1970          
1971          
1972          
1973          
1974          
1975          
C51 COMPILER V9.60.0.0   TASK3                                                             02/22/2021 15:08:10 PAGE 33  

1976          /***************************************************************************************
1977            * @说明   INT17中断服务函数
1978            * @参数 无
1979            * @返回值 无
1980            * @注   无
1981          ***************************************************************************************/
1982          void INT8_17_Rpt() interrupt INT8_17_VECTOR //右边
1983          {
1984   1        if(PINTF2&0x02)           //判断INT17中断标志位
1985   1        {
1986   2          if(f2_mode!=3&&f2_mode!=11)//不在充电和待机
1987   2          {
1988   3            num_R++;
1989   3            num_R2++;
1990   3            if(run_stop_flag_R ==1)//90°直角开始标志，在开始直角中触发开启
1991   3            {
1992   4              if(num_R2>1050)
1993   4              {
1994   5                run_stop_flag =1;//90°直角停止标志，在中断内触发
1995   5                reset_pwm();//重置PWM
1996   5                run_stop_flag_R =0;//90°直角开始标志，在开始直角中触发开启
1997   5              }   
1998   4            }
1999   3            if(run_stop_flag_R ==2)//90°直角开始标志，在碰撞直角中触发开启
2000   3            {
2001   4              if(num_R2>1050)
2002   4              {
2003   5                run_stop_flag =1;//90°直角停止标志，在中断内触发
2004   5                reset_pwm();//重置PWM
2005   5                run_stop_flag_R =0;//90°直角开始标志，在碰撞直角中触发开启
2006   5              }   
2007   4            }     
2008   3          }
2009   2          PINTF2 &=~ 0x02;        //清除INT17中断标志位 
2010   2          
2011   2        }
2012   1      }
2013          
2014          /****************中断记录左边轮编码器****************************/
2015          void P2INT_Rpt() interrupt P2INT_VECTOR 
2016          {
2017   1        
2018   1        if(PINTF2&0x80)           //判断P2中断标志位
2019   1        {
2020   2          if(f2_mode!=3&&f2_mode!=11)//不在充电和待机
2021   2          {
2022   3            num_L++;
2023   3            num_L2++;
2024   3            if(run_stop_flag_L ==1)//90°直角开始标志，在开始直角中触发开启
2025   3            {
2026   4              if(num_L2>1050)
2027   4              {
2028   5                run_stop_flag =1;//90°直角停止标志，在中断内触发
2029   5                reset_pwm();//重置PWM
2030   5                run_stop_flag_L =0;//90°直角开始标志，在开始直角中触发开启
2031   5              }   
2032   4            } 
2033   3            if(run_stop_flag_L ==2)//90°直角开始标志，在碰撞直角中触发开启
2034   3            {
2035   4              if(num_L2>1050)
2036   4              {
2037   5                run_stop_flag =1;//90°直角停止标志，在中断内触发
C51 COMPILER V9.60.0.0   TASK3                                                             02/22/2021 15:08:10 PAGE 34  

2038   5                reset_pwm();//重置PWM
2039   5                run_stop_flag_L =0;//90°直角开始标志，在碰撞直角中触发开启
2040   5              }   
2041   4            }
2042   3            
2043   3          }
2044   2          PINTF2 &=~ 0x80;        //清除P2中断标志位  
2045   2      
2046   2        }
2047   1      } 
2048          
2049          
2050          
2051          
2052          
2053          
2054          
2055          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6632    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     58      12
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
