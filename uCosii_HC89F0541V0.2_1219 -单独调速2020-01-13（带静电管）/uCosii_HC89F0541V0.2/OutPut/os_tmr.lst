C51 COMPILER V9.60.0.0   OS_TMR                                                            02/22/2021 15:08:12 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE OS_TMR
OBJECT MODULE PLACED IN .\OutPut\os_tmr.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE uCosii\os_tmr.c LARGE OPTIMIZE(9,SPEED) BROWSE INCDIR(.\Source;.\uCosii)
                    - DEBUG OBJECTEXTEND PRINT(.\OutPut\os_tmr.lst) TABS(2) OBJECT(.\OutPut\os_tmr.obj)

line level    source

   1          /*
   2          **********************************************************************************************************
             -**************
   3          *                                                uC/OS-II
   4          *                                          The Real-Time Kernel
   5          *                                            TIMER MANAGEMENT
   6          *
   7          *                              (c) Copyright 1992-2009, Micrium, Weston, FL
   8          *                                           All Rights Reserved
   9          *
  10          *
  11          * File    : OS_TMR.C
  12          * By      : Jean J. Labrosse
  13          * Version : V2.91
  14          *
  15          * LICENSING TERMS:
  16          * ---------------
  17          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
  18          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license
  19          * its use in your product. We provide ALL the source code for your convenience and to help you experience
  20          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
  21          * licensing fee.
  22          **********************************************************************************************************
             -**************
  23          */
  24          
  25          #ifndef __INCLUDES__
  26          #include "source\includes.h"
  27          #endif
  28          /*
  29          **********************************************************************************************************
             -**************
  30          *                                                        NOTES
  31          *
  32          * 1) Your application MUST define the following #define constants:
  33          *
  34          *    OS_TASK_TMR_PRIO          The priority of the Timer management task
  35          *    OS_TASK_TMR_STK_SIZE      The size     of the Timer management task's stack
  36          *
  37          * 2) You must call OSTmrSignal() to notify the Timer management task that it's time to update the timers.
  38          **********************************************************************************************************
             -**************
  39          */
  40          
  41          /*
  42          **********************************************************************************************************
             -**************
  43          *                                                     CONSTANTS
  44          **********************************************************************************************************
             -**************
  45          */
  46          
  47          #define  OS_TMR_LINK_DLY       0u
  48          #define  OS_TMR_LINK_PERIODIC  1u
C51 COMPILER V9.60.0.0   OS_TMR                                                            02/22/2021 15:08:12 PAGE 2   

  49          
  50          /*
  51          **********************************************************************************************************
             -**************
  52          *                                                  LOCAL PROTOTYPES
  53          **********************************************************************************************************
             -**************
  54          */
  55          
  56          #if OS_TMR_EN > 0u
              static  OS_TMR  *OSTmr_Alloc         (void) reentrant;
              static  void     OSTmr_Free          (OS_TMR *ptmr) reentrant;
              static  void     OSTmr_InitTask      (void);
              static  void     OSTmr_Link          (OS_TMR *ptmr, INT8U type) reentrant;
              static  void     OSTmr_Unlink        (OS_TMR *ptmr) reentrant;
              static  void     OSTmr_Task          (void   *p_arg) reentrant;
              #endif
  64          
  65          /*$PAGE*/
  66          /*
  67          **********************************************************************************************************
             -**************
  68          *                                                   CREATE A TIMER
  69          *
  70          * Description: This function is called by your application code to create a timer.
  71          *
  72          * Arguments  : dly           Initial delay.
  73          *                            If the timer is configured for ONE-SHOT mode, this is the timeout used
  74          *                            If the timer is configured for PERIODIC mode, this is the first timeout to wa
             -it for
  75          *                               before the timer starts entering periodic mode
  76          *
  77          *              period        The 'period' being repeated for the timer.
  78          *                               If you specified 'OS_TMR_OPT_PERIODIC' as an option, when the timer expire
             -s, it will
  79          *                               automatically restart with the same period.
  80          *
  81          *              opt           Specifies either:
  82          *                               OS_TMR_OPT_ONE_SHOT       The timer counts down only once
  83          *                               OS_TMR_OPT_PERIODIC       The timer counts down and then reloads itself
  84          *
  85          *              callback      Is a pointer to a callback function that will be called when the timer expire
             -s.  The
  86          *                               callback function must be declared as follows:
  87          *
  88          *                               void MyCallback (OS_TMR *ptmr, void *p_arg);
  89          *
  90          *              callback_arg  Is an argument (a pointer) that is passed to the callback function when it is
             - called.
  91          *
  92          *              pname         Is a pointer to an ASCII string that is used to name the timer.  Names are us
             -eful for
  93          *                               debugging.
  94          *
  95          *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
  96          *                               OS_ERR_NONE
  97          *                               OS_ERR_TMR_INVALID_DLY     you specified an invalid delay
  98          *                               OS_ERR_TMR_INVALID_PERIOD  you specified an invalid period
  99          *                               OS_ERR_TMR_INVALID_OPT     you specified an invalid option
 100          *                               OS_ERR_TMR_ISR             if the call was made from an ISR
 101          *                               OS_ERR_TMR_NON_AVAIL       if there are no free timers from the timer pool
 102          *
C51 COMPILER V9.60.0.0   OS_TMR                                                            02/22/2021 15:08:12 PAGE 3   

 103          * Returns    : A pointer to an OS_TMR data structure.
 104          *              This is the 'handle' that your application will use to reference the timer created.
 105          **********************************************************************************************************
             -**************
 106          */
 107          
 108          #if OS_TMR_EN > 0u
              OS_TMR  *OSTmrCreate (INT32U           dly,
                                    INT32U           period,
                                    INT8U            opt,
                                    OS_TMR_CALLBACK  callback,
                                    void            *callback_arg,
                                    INT8U           *pname,
                                    INT8U           *perr) reentrant
              {
                  OS_TMR   *ptmr;
              
              
              #ifdef OS_SAFETY_CRITICAL
                  if (perr == (INT8U *)0) {
                      OS_SAFETY_CRITICAL_EXCEPTION();
                  }
              #endif
              
              #ifdef OS_SAFETY_CRITICAL_IEC61508
                  if (OSSafetyCriticalStartFlag == OS_TRUE) {
                      OS_SAFETY_CRITICAL_EXCEPTION();
                  }
              #endif
              
              #if OS_ARG_CHK_EN > 0u
                  switch (opt) {                                          /* Validate arguments                         
             -            */
                      case OS_TMR_OPT_PERIODIC:
                           if (period == 0u) {
                               *perr = OS_ERR_TMR_INVALID_PERIOD;
                               return ((OS_TMR *)0);
                           }
                           break;
              
                      case OS_TMR_OPT_ONE_SHOT:
                           if (dly == 0u) {
                               *perr = OS_ERR_TMR_INVALID_DLY;
                               return ((OS_TMR *)0);
                           }
                           break;
              
                      default:
                           *perr = OS_ERR_TMR_INVALID_OPT;
                           return ((OS_TMR *)0);
                  }
              #endif
                  if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR          
             -            */
                      *perr  = OS_ERR_TMR_ISR;
                      return ((OS_TMR *)0);
                  }
                  OSSchedLock();
                  ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool          
             -            */
                  if (ptmr == (OS_TMR *)0) {
                      OSSchedUnlock();
C51 COMPILER V9.60.0.0   OS_TMR                                                            02/22/2021 15:08:12 PAGE 4   

                      *perr = OS_ERR_TMR_NON_AVAIL;
                      return ((OS_TMR *)0);
                  }
                  ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet     
             -            */
                  ptmr->OSTmrDly         = dly;
                  ptmr->OSTmrPeriod      = period;
                  ptmr->OSTmrOpt         = opt;
                  ptmr->OSTmrCallback    = callback;
                  ptmr->OSTmrCallbackArg = callback_arg;
              #if OS_TMR_CFG_NAME_EN > 0u
                  ptmr->OSTmrName        = pname;
              #endif
                  OSSchedUnlock();
                  *perr = OS_ERR_NONE;
                  return (ptmr);
              }
              #endif
 178          
 179          /*$PAGE*/
 180          /*
 181          **********************************************************************************************************
             -**************
 182          *                                                   DELETE A TIMER
 183          *
 184          * Description: This function is called by your application code to delete a timer.
 185          *
 186          * Arguments  : ptmr          Is a pointer to the timer to stop and delete.
 187          *
 188          *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
 189          *                               OS_ERR_NONE
 190          *                               OS_ERR_TMR_INVALID        'ptmr'  is a NULL pointer
 191          *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
 192          *                               OS_ERR_TMR_ISR            if the function was called from an ISR
 193          *                               OS_ERR_TMR_INACTIVE       if the timer was not created
 194          *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
 195          *
 196          * Returns    : OS_TRUE       If the call was successful
 197          *              OS_FALSE      If not
 198          **********************************************************************************************************
             -**************
 199          */
 200          
 201          #if OS_TMR_EN > 0u
              BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
                                 INT8U   *perr) reentrant
              {
              #ifdef OS_SAFETY_CRITICAL
                  if (perr == (INT8U *)0) {
                      OS_SAFETY_CRITICAL_EXCEPTION();
                  }
              #endif
              
              #if OS_ARG_CHK_EN > 0u
                  if (ptmr == (OS_TMR *)0) {
                      *perr = OS_ERR_TMR_INVALID;
                      return (OS_FALSE);
                  }
              #endif
                  if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                   
             -            */
                      *perr = OS_ERR_TMR_INVALID_TYPE;
C51 COMPILER V9.60.0.0   OS_TMR                                                            02/22/2021 15:08:12 PAGE 5   

                      return (OS_FALSE);
                  }
                  if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR          
             -            */
                      *perr  = OS_ERR_TMR_ISR;
                      return (OS_FALSE);
                  }
                  OSSchedLock();
                  switch (ptmr->OSTmrState) {
                      case OS_TMR_STATE_RUNNING:
                           OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke            
             -            */
                           OSTmr_Free(ptmr);                              /* Return timer to free list of timers        
             -            */
                           OSSchedUnlock();
                           *perr = OS_ERR_NONE;
                           return (OS_TRUE);
              
                      case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...               
             -            */
                      case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time  
             -            */
                           OSTmr_Free(ptmr);                              /* Return timer to free list of timers        
             -            */
                           OSSchedUnlock();
                           *perr = OS_ERR_NONE;
                           return (OS_TRUE);
              
                      case OS_TMR_STATE_UNUSED:                           /* Already deleted                            
             -            */
                           OSSchedUnlock();
                           *perr = OS_ERR_TMR_INACTIVE;
                           return (OS_FALSE);
              
                      default:
                           OSSchedUnlock();
                           *perr = OS_ERR_TMR_INVALID_STATE;
                           return (OS_FALSE);
                  }
              }
              #endif
 253          
 254          /*$PAGE*/
 255          /*
 256          **********************************************************************************************************
             -**************
 257          *                                             GET THE NAME OF A TIMER
 258          *
 259          * Description: This function is called to obtain the name of a timer.
 260          *
 261          * Arguments  : ptmr          Is a pointer to the timer to obtain the name for
 262          *
 263          *              pdest         Is a pointer to pointer to where the name of the timer will be placed.
 264          *
 265          *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
 266          *                               OS_ERR_NONE               The call was successful
 267          *                               OS_ERR_TMR_INVALID_DEST   'pdest' is a NULL pointer
 268          *                               OS_ERR_TMR_INVALID        'ptmr'  is a NULL pointer
 269          *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
 270          *                               OS_ERR_NAME_GET_ISR       if the call was made from an ISR
 271          *                               OS_ERR_TMR_INACTIVE       'ptmr'  points to a timer that is not active
 272          *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
C51 COMPILER V9.60.0.0   OS_TMR                                                            02/22/2021 15:08:12 PAGE 6   

 273          *
 274          * Returns    : The length of the string or 0 if the timer does not exist.
 275          **********************************************************************************************************
             -**************
 276          */
 277          
 278          #if OS_TMR_EN > 0u && OS_TMR_CFG_NAME_EN > 0u
              INT8U  OSTmrNameGet (OS_TMR   *ptmr,
                                   INT8U   **pdest,
                                   INT8U    *perr) reentrant
              {
                  INT8U  len;
              
              
              #ifdef OS_SAFETY_CRITICAL
                  if (perr == (INT8U *)0) {
                      OS_SAFETY_CRITICAL_EXCEPTION();
                  }
              #endif
              
              #if OS_ARG_CHK_EN > 0u
                  if (pdest == (INT8U **)0) {
                      *perr = OS_ERR_TMR_INVALID_DEST;
                      return (0u);
                  }
                  if (ptmr == (OS_TMR *)0) {
                      *perr = OS_ERR_TMR_INVALID;
                      return (0u);
                  }
              #endif
                  if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                        
             -            */
                      *perr = OS_ERR_TMR_INVALID_TYPE;
                      return (0u);
                  }
                  if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR               
             -            */
                      *perr = OS_ERR_NAME_GET_ISR;
                      return (0u);
                  }
                  OSSchedLock();
                  switch (ptmr->OSTmrState) {
                      case OS_TMR_STATE_RUNNING:
                      case OS_TMR_STATE_STOPPED:
                      case OS_TMR_STATE_COMPLETED:
                           *pdest = ptmr->OSTmrName;
                           len    = OS_StrLen(*pdest);
                           OSSchedUnlock();
                           *perr = OS_ERR_NONE;
                           return (len);
              
                      case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                          
             -            */
                           OSSchedUnlock();
                           *perr = OS_ERR_TMR_INACTIVE;
                           return (0u);
              
                      default:
                           OSSchedUnlock();
                           *perr = OS_ERR_TMR_INVALID_STATE;
                           return (0u);
                  }
C51 COMPILER V9.60.0.0   OS_TMR                                                            02/22/2021 15:08:12 PAGE 7   

              }
              #endif
 333          
 334          /*$PAGE*/
 335          /*
 336          **********************************************************************************************************
             -**************
 337          *                                    GET HOW MUCH TIME IS LEFT BEFORE A TIMER EXPIRES
 338          *
 339          * Description: This function is called to get the number of ticks before a timer times out.
 340          *
 341          * Arguments  : ptmr          Is a pointer to the timer to obtain the remaining time from.
 342          *
 343          *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
 344          *                               OS_ERR_NONE
 345          *                               OS_ERR_TMR_INVALID        'ptmr' is a NULL pointer
 346          *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
 347          *                               OS_ERR_TMR_ISR            if the call was made from an ISR
 348          *                               OS_ERR_TMR_INACTIVE       'ptmr' points to a timer that is not active
 349          *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
 350          *
 351          * Returns    : The time remaining for the timer to expire.  The time represents 'timer' increments.  In ot
             -her words, if
 352          *              OSTmr_Task() is signaled every 1/10 of a second then the returned value represents the numb
             -er of 1/10 of
 353          *              a second remaining before the timer expires.
 354          **********************************************************************************************************
             -**************
 355          */
 356          
 357          #if OS_TMR_EN > 0u
              INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
                                      INT8U   *perr) reentrant
              {
                  INT32U  remain;
              
              
              #ifdef OS_SAFETY_CRITICAL
                  if (perr == (INT8U *)0) {
                      OS_SAFETY_CRITICAL_EXCEPTION();
                  }
              #endif
              
              #if OS_ARG_CHK_EN > 0u
                  if (ptmr == (OS_TMR *)0) {
                      *perr = OS_ERR_TMR_INVALID;
                      return (0u);
                  }
              #endif
                  if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                        
             -            */
                      *perr = OS_ERR_TMR_INVALID_TYPE;
                      return (0u);
                  }
                  if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR               
             -            */
                      *perr = OS_ERR_TMR_ISR;
                      return (0u);
                  }
                  OSSchedLock();
                  switch (ptmr->OSTmrState) {
                      case OS_TMR_STATE_RUNNING:
C51 COMPILER V9.60.0.0   OS_TMR                                                            02/22/2021 15:08:12 PAGE 8   

                           remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout      
             -            */
                           OSSchedUnlock();
                           *perr  = OS_ERR_NONE;
                           return (remain);
              
                      case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet 
             -            */
                           switch (ptmr->OSTmrOpt) {
                               case OS_TMR_OPT_PERIODIC:
                                    if (ptmr->OSTmrDly == 0u) {
                                        remain = ptmr->OSTmrPeriod;
                                    } else {
                                        remain = ptmr->OSTmrDly;
                                    }
                                    OSSchedUnlock();
                                    *perr  = OS_ERR_NONE;
                                    break;
              
                               case OS_TMR_OPT_ONE_SHOT:
                               default:
                                    remain = ptmr->OSTmrDly;
                                    OSSchedUnlock();
                                    *perr  = OS_ERR_NONE;
                                    break;
                           }
                           return (remain);
              
                      case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this stat
             -e           */
                           OSSchedUnlock();
                           *perr = OS_ERR_NONE;
                           return (0u);
              
                      case OS_TMR_STATE_UNUSED:
                           OSSchedUnlock();
                           *perr = OS_ERR_TMR_INACTIVE;
                           return (0u);
              
                      default:
                           OSSchedUnlock();
                           *perr = OS_ERR_TMR_INVALID_STATE;
                           return (0u);
                  }
              }
              #endif
 430          
 431          /*$PAGE*/
 432          /*
 433          **********************************************************************************************************
             -**************
 434          *                                    FIND OUT WHAT STATE A TIMER IS IN
 435          *
 436          * Description: This function is called to determine what state the timer is in:
 437          *
 438          *                  OS_TMR_STATE_UNUSED     the timer has not been created
 439          *                  OS_TMR_STATE_STOPPED    the timer has been created but has not been started or has been
             - stopped
 440          *                  OS_TMR_COMPLETED        the timer is in ONE-SHOT mode and has completed it's timeout
 441          *                  OS_TMR_RUNNING          the timer is currently running
 442          *
 443          * Arguments  : ptmr          Is a pointer to the desired timer
C51 COMPILER V9.60.0.0   OS_TMR                                                            02/22/2021 15:08:12 PAGE 9   

 444          *
 445          *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
 446          *                               OS_ERR_NONE
 447          *                               OS_ERR_TMR_INVALID        'ptmr' is a NULL pointer
 448          *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
 449          *                               OS_ERR_TMR_ISR            if the call was made from an ISR
 450          *                               OS_ERR_TMR_INACTIVE       'ptmr' points to a timer that is not active
 451          *                               OS_ERR_TMR_INVALID_STATE  if the timer is not in a valid state
 452          *
 453          * Returns    : The current state of the timer (see description).
 454          **********************************************************************************************************
             -**************
 455          */
 456          
 457          #if OS_TMR_EN > 0u
              INT8U  OSTmrStateGet (OS_TMR  *ptmr,
                                    INT8U   *perr) reentrant
              {
                  INT8U  state;
              
              
              #ifdef OS_SAFETY_CRITICAL
                  if (perr == (INT8U *)0) {
                      OS_SAFETY_CRITICAL_EXCEPTION();
                  }
              #endif
              
              #if OS_ARG_CHK_EN > 0u
                  if (ptmr == (OS_TMR *)0) {
                      *perr = OS_ERR_TMR_INVALID;
                      return (0u);
                  }
              #endif
                  if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                        
             -            */
                      *perr = OS_ERR_TMR_INVALID_TYPE;
                      return (0u);
                  }
                  if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR               
             -            */
                      *perr = OS_ERR_TMR_ISR;
                      return (0u);
                  }
                  OSSchedLock();
                  state = ptmr->OSTmrState;
                  switch (state) {
                      case OS_TMR_STATE_UNUSED:
                      case OS_TMR_STATE_STOPPED:
                      case OS_TMR_STATE_COMPLETED:
                      case OS_TMR_STATE_RUNNING:
                           *perr = OS_ERR_NONE;
                           break;
              
                      default:
                           *perr = OS_ERR_TMR_INVALID_STATE;
                           break;
                  }
                  OSSchedUnlock();
                  return (state);
              }
              #endif
 502          
C51 COMPILER V9.60.0.0   OS_TMR                                                            02/22/2021 15:08:12 PAGE 10  

 503          /*$PAGE*/
 504          /*
 505          **********************************************************************************************************
             -**************
 506          *                                                   START A TIMER
 507          *
 508          * Description: This function is called by your application code to start a timer.
 509          *
 510          * Arguments  : ptmr          Is a pointer to an OS_TMR
 511          *
 512          *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
 513          *                               OS_ERR_NONE
 514          *                               OS_ERR_TMR_INVALID
 515          *                               OS_ERR_TMR_INVALID_TYPE    'ptmr'  is not pointing to an OS_TMR
 516          *                               OS_ERR_TMR_ISR             if the call was made from an ISR
 517          *                               OS_ERR_TMR_INACTIVE        if the timer was not created
 518          *                               OS_ERR_TMR_INVALID_STATE   the timer is in an invalid state
 519          *
 520          * Returns    : OS_TRUE    if the timer was started
 521          *              OS_FALSE   if an error was detected
 522          **********************************************************************************************************
             -**************
 523          */
 524          
 525          #if OS_TMR_EN > 0u
              BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
                                   INT8U    *perr) reentrant
              {
              #ifdef OS_SAFETY_CRITICAL
                  if (perr == (INT8U *)0) {
                      OS_SAFETY_CRITICAL_EXCEPTION();
                  }
              #endif
              
              #if OS_ARG_CHK_EN > 0u
                  if (ptmr == (OS_TMR *)0) {
                      *perr = OS_ERR_TMR_INVALID;
                      return (OS_FALSE);
                  }
              #endif
                  if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                   
             -            */
                      *perr = OS_ERR_TMR_INVALID_TYPE;
                      return (OS_FALSE);
                  }
                  if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR          
             -            */
                      *perr  = OS_ERR_TMR_ISR;
                      return (OS_FALSE);
                  }
                  OSSchedLock();
                  switch (ptmr->OSTmrState) {
                      case OS_TMR_STATE_RUNNING:                          /* Restart the timer                          
             -            */
                           OSTmr_Unlink(ptmr);                            /* ... Stop the timer                         
             -            */
                           OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel              
             -            */
                           OSSchedUnlock();
                           *perr = OS_ERR_NONE;
                           return (OS_TRUE);
              
C51 COMPILER V9.60.0.0   OS_TMR                                                            02/22/2021 15:08:12 PAGE 11  

                      case OS_TMR_STATE_STOPPED:                          /* Start the timer                            
             -            */
                      case OS_TMR_STATE_COMPLETED:
                           OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel              
             -            */
                           OSSchedUnlock();
                           *perr = OS_ERR_NONE;
                           return (OS_TRUE);
              
                      case OS_TMR_STATE_UNUSED:                           /* Timer not created                          
             -            */
                           OSSchedUnlock();
                           *perr = OS_ERR_TMR_INACTIVE;
                           return (OS_FALSE);
              
                      default:
                           OSSchedUnlock();
                           *perr = OS_ERR_TMR_INVALID_STATE;
                           return (OS_FALSE);
                  }
              }
              #endif
 577          
 578          /*$PAGE*/
 579          /*
 580          **********************************************************************************************************
             -**************
 581          *                                                   STOP A TIMER
 582          *
 583          * Description: This function is called by your application code to stop a timer.
 584          *
 585          * Arguments  : ptmr          Is a pointer to the timer to stop.
 586          *
 587          *              opt           Allows you to specify an option to this functions which can be:
 588          *
 589          *                               OS_TMR_OPT_NONE          Do nothing special but stop the timer
 590          *                               OS_TMR_OPT_CALLBACK      Execute the callback function, pass it the callba
             -ck argument
 591          *                                                        specified when the timer was created.
 592          *                               OS_TMR_OPT_CALLBACK_ARG  Execute the callback function, pass it the callba
             -ck argument
 593          *                                                        specified in THIS function call
 594          *
 595          *              callback_arg  Is a pointer to a 'new' callback argument that can be passed to the callback 
             -function
 596          *                               instead of the timer's callback argument.  In other words, use 'callback_a
             -rg' passed in
 597          *                               THIS function INSTEAD of ptmr->OSTmrCallbackArg
 598          *
 599          *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
 600          *                               OS_ERR_NONE
 601          *                               OS_ERR_TMR_INVALID         'ptmr' is a NULL pointer
 602          *                               OS_ERR_TMR_INVALID_TYPE    'ptmr'  is not pointing to an OS_TMR
 603          *                               OS_ERR_TMR_ISR             if the function was called from an ISR
 604          *                               OS_ERR_TMR_INACTIVE        if the timer was not created
 605          *                               OS_ERR_TMR_INVALID_OPT     if you specified an invalid option for 'opt'
 606          *                               OS_ERR_TMR_STOPPED         if the timer was already stopped
 607          *                               OS_ERR_TMR_INVALID_STATE   the timer is in an invalid state
 608          *                               OS_ERR_TMR_NO_CALLBACK     if the timer does not have a callback function 
             -defined
 609          *
 610          * Returns    : OS_TRUE       If we stopped the timer (if the timer is already stopped, we also return OS_T
C51 COMPILER V9.60.0.0   OS_TMR                                                            02/22/2021 15:08:12 PAGE 12  

             -RUE)
 611          *              OS_FALSE      If not
 612          **********************************************************************************************************
             -**************
 613          */
 614          
 615          #if OS_TMR_EN > 0u
              BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
                                  INT8U    opt,
                                  void    *callback_arg,
                                  INT8U   *perr) reentrant
              {
                  OS_TMR_CALLBACK  pfnct;
              
              
              #ifdef OS_SAFETY_CRITICAL
                  if (perr == (INT8U *)0) {
                      OS_SAFETY_CRITICAL_EXCEPTION();
                  }
              #endif
              
              #if OS_ARG_CHK_EN > 0u
                  if (ptmr == (OS_TMR *)0) {
                      *perr = OS_ERR_TMR_INVALID;
                      return (OS_FALSE);
                  }
              #endif
                  if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure             
             -            */
                      *perr = OS_ERR_TMR_INVALID_TYPE;
                      return (OS_FALSE);
                  }
                  if (OSIntNesting > 0u) {                                      /* See if trying to call from an ISR    
             -            */
                      *perr  = OS_ERR_TMR_ISR;
                      return (OS_FALSE);
                  }
                  OSSchedLock();
                  switch (ptmr->OSTmrState) {
                      case OS_TMR_STATE_RUNNING:
                           OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke      
             -            */
                           *perr = OS_ERR_NONE;
                           switch (opt) {
                               case OS_TMR_OPT_CALLBACK:
                                    pfnct = ptmr->OSTmrCallback;                /* Execute callback function if availabl
             -e ...       */
                                    if (pfnct != (OS_TMR_CALLBACK)0) {
                                        (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer 
             -was created */
                                    } else {
                                        *perr = OS_ERR_TMR_NO_CALLBACK;
                                    }
                                    break;
              
                               case OS_TMR_OPT_CALLBACK_ARG:
                                    pfnct = ptmr->OSTmrCallback;                /* Execute callback function if availabl
             -e ...       */
                                    if (pfnct != (OS_TMR_CALLBACK)0) {
                                        (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided
             - in call    */
                                    } else {
C51 COMPILER V9.60.0.0   OS_TMR                                                            02/22/2021 15:08:12 PAGE 13  

                                        *perr = OS_ERR_TMR_NO_CALLBACK;
                                    }
                                    break;
              
                               case OS_TMR_OPT_NONE:
                                    break;
              
                               default:
                                   *perr = OS_ERR_TMR_INVALID_OPT;
                                   break;
                           }
                           OSSchedUnlock();
                           return (OS_TRUE);
              
                      case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-S
             -HOT or ...  */
                      case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.       
             -            */
                           OSSchedUnlock();
                           *perr = OS_ERR_TMR_STOPPED;
                           return (OS_TRUE);
              
                      case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                
             -            */
                           OSSchedUnlock();
                           *perr = OS_ERR_TMR_INACTIVE;
                           return (OS_FALSE);
              
                      default:
                           OSSchedUnlock();
                           *perr = OS_ERR_TMR_INVALID_STATE;
                           return (OS_FALSE);
                  }
              }
              #endif
 696          
 697          /*$PAGE*/
 698          /*
 699          **********************************************************************************************************
             -**************
 700          *                                      SIGNAL THAT IT'S TIME TO UPDATE THE TIMERS
 701          *
 702          * Description: This function is typically called by the ISR that occurs at the timer tick rate and is used
             - to signal to
 703          *              OSTmr_Task() that it's time to update the timers.
 704          *
 705          * Arguments  : none
 706          *
 707          * Returns    : OS_ERR_NONE         The call was successful and the timer task was signaled.
 708          *              OS_ERR_SEM_OVF      If OSTmrSignal() was called more often than OSTmr_Task() can handle the
             - timers.
 709          *                                  This would indicate that your system is heavily loaded.
 710          *              OS_ERR_EVENT_TYPE   Unlikely you would get this error because the semaphore used for signal
             -ing is created
 711          *                                  by uC/OS-II.
 712          *              OS_ERR_PEVENT_NULL  Again, unlikely you would ever get this error because the semaphore use
             -d for signaling
 713          *                                  is created by uC/OS-II.
 714          **********************************************************************************************************
             -**************
 715          */
 716          
C51 COMPILER V9.60.0.0   OS_TMR                                                            02/22/2021 15:08:12 PAGE 14  

 717          #if OS_TMR_EN > 0u
              INT8U  OSTmrSignal (void) reentrant
              {
                  INT8U  err;
              
              
                  err = OSSemPost(OSTmrSemSignal);
                  return (err);
              }
              #endif
 727          
 728          /*$PAGE*/
 729          /*
 730          **********************************************************************************************************
             -**************
 731          *                                               ALLOCATE AND FREE A TIMER
 732          *
 733          * Description: This function is called to allocate a timer.
 734          *
 735          * Arguments  : none
 736          *
 737          * Returns    : a pointer to a timer if one is available
 738          **********************************************************************************************************
             -**************
 739          */
 740          
 741          #if OS_TMR_EN > 0u
              static  OS_TMR  *OSTmr_Alloc (void) reentrant
              {
                  OS_TMR *ptmr;
              
              
                  if (OSTmrFreeList == (OS_TMR *)0) {
                      return ((OS_TMR *)0);
                  }
                  ptmr            = (OS_TMR *)OSTmrFreeList;
                  OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
                  ptmr->OSTmrNext = (OS_TCB *)0;
                  ptmr->OSTmrPrev = (OS_TCB *)0;
                  OSTmrUsed++;
                  OSTmrFree--;
                  return (ptmr);
              }
              #endif
 759          
 760          
 761          /*
 762          **********************************************************************************************************
             -**************
 763          *                                             RETURN A TIMER TO THE FREE LIST
 764          *
 765          * Description: This function is called to return a timer object to the free list of timers.
 766          *
 767          * Arguments  : ptmr     is a pointer to the timer to free
 768          *
 769          * Returns    : none
 770          **********************************************************************************************************
             -**************
 771          */
 772          
 773          #if OS_TMR_EN > 0u
              static  void  OSTmr_Free (OS_TMR *ptmr) reentrant
C51 COMPILER V9.60.0.0   OS_TMR                                                            02/22/2021 15:08:12 PAGE 15  

              {
                  ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                       
             -            */
                  ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
                  ptmr->OSTmrPeriod      = 0u;
                  ptmr->OSTmrMatch       = 0u;
                  ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
                  ptmr->OSTmrCallbackArg = (void *)0;
              #if OS_TMR_CFG_NAME_EN > 0u
                  ptmr->OSTmrName        = (INT8U *)(void *)"?";
              #endif
              
                  ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                        
             -            */
                  ptmr->OSTmrNext        = OSTmrFreeList;
                  OSTmrFreeList          = ptmr;
              
                  OSTmrUsed--;                                       /* Update timer object statistics                  
             -            */
                  OSTmrFree++;
              }
              #endif
 794          
 795          /*$PAGE*/
 796          /*
 797          **********************************************************************************************************
             -**************
 798          *                                                    INITIALIZATION
 799          *                                          INITIALIZE THE FREE LIST OF TIMERS
 800          *
 801          * Description: This function is called by OSInit() to initialize the free list of OS_TMRs.
 802          *
 803          * Arguments  : none
 804          *
 805          * Returns    : none
 806          **********************************************************************************************************
             -**************
 807          */
 808          
 809          #if OS_TMR_EN > 0u
              void  OSTmr_Init (void) reentrant
              {
              #if OS_EVENT_NAME_EN > 0u
                  INT8U    err;
              #endif
                  INT16U   ix;
                  INT16U   ix_next;
                  OS_TMR  *ptmr1;
                  OS_TMR  *ptmr2;
              
              
                  OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs             
             -            */
                  OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel          
             -            */
              
                  for (ix = 0u; ix < (OS_TMR_CFG_MAX - 1u); ix++) {                   /* Init. list of free TMRs        
             -            */
                      ix_next = ix + 1u;
                      ptmr1 = &OSTmrTbl[ix];
                      ptmr2 = &OSTmrTbl[ix_next];
                      ptmr1->OSTmrType    = OS_TMR_TYPE;
C51 COMPILER V9.60.0.0   OS_TMR                                                            02/22/2021 15:08:12 PAGE 16  

                      ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive
             -            */
                      ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer             
             -            */
              #if OS_TMR_CFG_NAME_EN > 0u
                      ptmr1->OSTmrName    = (INT8U *)(void *)"?";
              #endif
                  }
                  ptmr1               = &OSTmrTbl[ix];
                  ptmr1->OSTmrType    = OS_TMR_TYPE;
                  ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive
             -            */
                  ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                    
             -            */
              #if OS_TMR_CFG_NAME_EN > 0u
                  ptmr1->OSTmrName    = (INT8U *)(void *)"?";
              #endif
                  OSTmrTime           = 0u;
                  OSTmrUsed           = 0u;
                  OSTmrFree           = OS_TMR_CFG_MAX;
                  OSTmrFreeList       = &OSTmrTbl[0];
                  OSTmrSem            = OSSemCreate(1u);
                  OSTmrSemSignal      = OSSemCreate(0u);
              
              #if OS_EVENT_NAME_EN > 0u                                               /* Assign names to semaphores     
             -            */
                  OSEventNameSet(OSTmrSem,       (INT8U *)(void *)"uC/OS-II TmrLock",   &err);
                  OSEventNameSet(OSTmrSemSignal, (INT8U *)(void *)"uC/OS-II TmrSignal", &err);
              #endif
              
                  OSTmr_InitTask();
              }
              #endif
 857          
 858          /*$PAGE*/
 859          /*
 860          **********************************************************************************************************
             -**************
 861          *                                          INITIALIZE THE TIMER MANAGEMENT TASK
 862          *
 863          * Description: This function is called by OSTmrInit() to create the timer management task.
 864          *                               * Arguments  : none
 865          *
 866          * Returns    : none
 867          **********************************************************************************************************
             -**************
 868          */
 869          
 870          #if OS_TMR_EN > 0u
              static  void  OSTmr_InitTask (void) reentrant
              {
              #if OS_TASK_NAME_EN > 0u
                  INT8U  err;
              #endif
              
              
              #if OS_TASK_CREATE_EXT_EN > 0u
                  #if OS_STK_GROWTH == 1u
                  (void)OSTaskCreateExt(OSTmr_Task,
                                        (void *)0,                                       /* No arguments passed to OSTmr
             -Task()      */
                                        &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],        /* Set Top-Of-Stack            
C51 COMPILER V9.60.0.0   OS_TMR                                                            02/22/2021 15:08:12 PAGE 17  

             -            */
                                        OS_TASK_TMR_PRIO,
                                        OS_TASK_TMR_ID,
                                        &OSTmrTaskStk[0],                                /* Set Bottom-Of-Stack         
             -            */
                                        OS_TASK_TMR_STK_SIZE,
                                        (void *)0,                                       /* No TCB extension            
             -            */
                                        OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);      /* Enable stack checking + clea
             -r stack     */
                  #else
                  (void)OSTaskCreateExt(OSTmr_Task,
                                        (void *)0,                                       /* No arguments passed to OSTmr
             -Task()      */
                                        &OSTmrTaskStk[0],                                /* Set Top-Of-Stack            
             -            */
                                        OS_TASK_TMR_PRIO,
                                        OS_TASK_TMR_ID,
                                        &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],        /* Set Bottom-Of-Stack         
             -            */
                                        OS_TASK_TMR_STK_SIZE,
                                        (void *)0,                                       /* No TCB extension            
             -            */
                                        OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);      /* Enable stack checking + clea
             -r stack     */
                  #endif
              #else
                  #if OS_STK_GROWTH == 1u
                  (void)OSTaskCreate(OSTmr_Task,
                                     (void *)0,
                                     &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],
                                     OS_TASK_TMR_PRIO);
                  #else
                  (void)OSTaskCreate(OSTmr_Task,
                                     (void *)0,
                                     &OSTmrTaskStk[0],
                                     OS_TASK_TMR_PRIO);
                  #endif
              #endif
              
              #if OS_TASK_NAME_EN > 0u
                  OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)(void *)"uC/OS-II Tmr", &err);
              #endif
              }
              #endif
 919          
 920          /*$PAGE*/
 921          /*
 922          **********************************************************************************************************
             -**************
 923          *                                         INSERT A TIMER INTO THE TIMER WHEEL
 924          *
 925          * Description: This function is called to insert the timer into the timer wheel.  The timer is always inse
             -rted at the
 926          *              beginning of the list.
 927          *
 928          * Arguments  : ptmr          Is a pointer to the timer to insert.
 929          *
 930          *              type          Is either:
 931          *                               OS_TMR_LINK_PERIODIC    Means to re-insert the timer after a period expire
             -d
 932          *                               OS_TMR_LINK_DLY         Means to insert    the timer the first time
C51 COMPILER V9.60.0.0   OS_TMR                                                            02/22/2021 15:08:12 PAGE 18  

 933          *
 934          * Returns    : none
 935          **********************************************************************************************************
             -**************
 936          */
 937          
 938          #if OS_TMR_EN > 0u
              static  void  OSTmr_Link (OS_TMR  *ptmr,
                                        INT8U    type) reentrant
              {
                  OS_TMR       *ptmr1;
                  OS_TMR_WHEEL *pspoke;
                  INT16U        spoke;
              
              
                  ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
                  if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire    
             -            */
                      ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
                  } else {
                      if (ptmr->OSTmrDly == 0u) {
                          ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
                      } else {
                          ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
                      }
                  }
                  spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
                  pspoke = &OSTmrWheelTbl[spoke];
              
                  if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel               
             -            */
                      pspoke->OSTmrFirst   = ptmr;
                      ptmr->OSTmrNext      = (OS_TMR *)0;
                      pspoke->OSTmrEntries = 1u;
                  } else {
                      ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke   
             -            */
                      pspoke->OSTmrFirst   = ptmr;
                      ptmr->OSTmrNext      = (void *)ptmr1;
                      ptmr1->OSTmrPrev     = (void *)ptmr;
                      pspoke->OSTmrEntries++;
                  }
                  ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node 
             -in list     */
              }
              #endif
 974          
 975          /*$PAGE*/
 976          /*
 977          **********************************************************************************************************
             -**************
 978          *                                         REMOVE A TIMER FROM THE TIMER WHEEL
 979          *
 980          * Description: This function is called to remove the timer from the timer wheel.
 981          *
 982          * Arguments  : ptmr          Is a pointer to the timer to remove.
 983          *
 984          * Returns    : none
 985          **********************************************************************************************************
             -**************
 986          */
 987          
C51 COMPILER V9.60.0.0   OS_TMR                                                            02/22/2021 15:08:12 PAGE 19  

 988          #if OS_TMR_EN > 0u
              static  void  OSTmr_Unlink (OS_TMR *ptmr) reentrant
              {
                  OS_TMR        *ptmr1;
                  OS_TMR        *ptmr2;
                  OS_TMR_WHEEL  *pspoke;
                  INT16U         spoke;
              
              
                  spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
                  pspoke = &OSTmrWheelTbl[spoke];
              
                  if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning 
             -of list     */
                      ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
                      pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
                      if (ptmr1 != (OS_TMR *)0) {
                          ptmr1->OSTmrPrev = (void *)0;
                      }
                  } else {
                      ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list    
             -            */
                      ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
                      ptmr1->OSTmrNext = ptmr2;
                      if (ptmr2 != (OS_TMR *)0) {
                          ptmr2->OSTmrPrev = (void *)ptmr1;
                      }
                  }
                  ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
                  ptmr->OSTmrNext  = (void *)0;
                  ptmr->OSTmrPrev  = (void *)0;
                  pspoke->OSTmrEntries--;
              }
              #endif
1020          
1021          /*$PAGE*/
1022          /*
1023          **********************************************************************************************************
             -**************
1024          *                                                 TIMER MANAGEMENT TASK
1025          *
1026          * Description: This task is created by OSTmrInit().
1027          *
1028          * Arguments  : none
1029          *
1030          * Returns    : none
1031          **********************************************************************************************************
             -**************
1032          */
1033          
1034          #if OS_TMR_EN > 0u
              static  void  OSTmr_Task (void *p_arg) reentrant
              {
                  INT8U            err;
                  OS_TMR          *ptmr;
                  OS_TMR          *ptmr_next;
                  OS_TMR_CALLBACK  pfnct;
                  OS_TMR_WHEEL    *pspoke;
                  INT16U           spoke;
              
              
                  p_arg = p_arg;                                               /* Prevent compiler warning for not using
C51 COMPILER V9.60.0.0   OS_TMR                                                            02/22/2021 15:08:12 PAGE 20  

             - 'p_arg'    */
                  for (;;) {
                      OSSemPend(OSTmrSemSignal, 0u, &err);                     /* Wait for signal indicating time to upd
             -ate timers  */
                      OSSchedLock();
                      OSTmrTime++;                                             /* Increment the current time            
             -            */
                      spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry 
             -            */
                      pspoke = &OSTmrWheelTbl[spoke];
                      ptmr   = pspoke->OSTmrFirst;
                      while (ptmr != (OS_TMR *)0) {
                          ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because 
             -current ... */
                                                                               /* ... timer could get unlinked from the 
             -wheel.      */
                          if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires       
             -            */
                              OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke       
             -            */
                              if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
                                  OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in w
             -heel        */
                              } else {
                                  ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed 
             -            */
                              }
                              pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available
             -            */
                              if (pfnct != (OS_TMR_CALLBACK)0) {
                                  (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
                              }
                          }
                          ptmr = ptmr_next;
                      }
                      OSSchedUnlock();
                  }
              }
              #endif
1074                                                                                                                                                       
             -                                                                                


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   ----    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
